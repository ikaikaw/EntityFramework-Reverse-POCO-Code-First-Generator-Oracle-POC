<#
// Copyright (C) Simon Hughes 2012
// v2.36.1
#>
<#@ template debug="true" hostspecific="true" language="C#" #>
<#@ include file="EF6.Utility.CS.ttinclude"#>
<#@ assembly name="$(SolutionDir)\packages\Oracle.ManagedDataAccess.12.2.1100\lib\net40\Oracle.ManagedDataAccess.dll" #>
<#@ assembly name="System.Configuration" #>
<#@ assembly name="System.Windows.Forms" #>
<#@ import namespace="System.Data" #>
<#@ import namespace="System.Data.SqlClient" #>
<#@ import namespace="System.Data.Common" #>
<#@ import namespace="System.Data.Entity.Infrastructure.Pluralization" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Configuration" #>
<#@ import namespace="System.Runtime.CompilerServices" #>
<#@ import namespace="EnvDTE" #>
<#@ output extension=".cs"#>
<#
        var DefaultNamespace = new CodeGenerationTools(this).VsNamespaceSuggestion() ?? "DebugMode";
        var fileManager = EntityFrameworkTemplateFileManager.Create(this);
#>
<#+
    [Flags]
    public enum CommentsStyle
    {
        None,
        InSummaryBlock,
        AtEndOfField
    };

    // Settings to allow selective code generation
    [Flags]
    public enum Elements
    {
        None = 0,
        Poco = 1,
        Context = 2,
        UnitOfWork = 4,
        PocoConfiguration = 8
    };

    // Settings - edit these in the main <name>.tt file *******************************************************************************
    public static class Settings
    {
        // Main settings
        public static string ConnectionStringName;
        public static string ConnectionString;
        public static string ProviderName;
        public static string Namespace;
        public static int CommandTimeout = 0;

        public static bool IncludeViews;
        public static bool IncludeSynonyms;
        public static bool IncludeStoredProcedures;
        public static bool IncludeTableValuedFunctions;
        public static bool AddIDbContextFactory;
        public static bool AddUnitTestingDbContext;
        public static string DbContextName;

        private static string _dbContextInterfaceName;
        public static string DbContextInterfaceName
        {
            get { return _dbContextInterfaceName ?? ("I" + DbContextName); }
            set { _dbContextInterfaceName = value; }
        }

        public static string DbContextInterfaceBaseClasses;
        public static string DbContextBaseClass;

        private static string _defaultConstructorArgument;
        public static string DefaultConstructorArgument
        {
            get { return _defaultConstructorArgument ?? string.Format('"' + "Name={0}" + '"', ConnectionStringName); }
            set { _defaultConstructorArgument = value; }
        }

        public static string ConfigurationClassName = "Configuration";
        public static string CollectionInterfaceType = "System.Collections.Generic.ICollection";
        public static string CollectionType = "System.Collections.Generic.List";
        public static bool NullableShortHand;
        public static bool UseDataAnnotations;
        public static bool MakeClassesPartial;
        public static bool MakeClassesInternal;
        public static bool MakeDbContextInterfacePartial;
        public static bool GenerateSeparateFiles;
        public static bool UseMappingTables;
        public static bool UsePropertyInitializers;
        public static bool IsSqlCe;
        public static string FileExtension = ".cs";
        public static bool UsePascalCase;
        public static bool UsePrivateSetterForComputedColumns;
        public static CommentsStyle IncludeComments = CommentsStyle.AtEndOfField;
        public static bool IncludeQueryTraceOn9481Flag;
        public static CommentsStyle IncludeExtendedPropertyComments = CommentsStyle.InSummaryBlock;
        public static bool IncludeConnectionSettingComments;
        public static bool DisableGeographyTypes;
        public static bool PrependSchemaName;
        public static string TableSuffix;
        public static Regex SchemaFilterExclude;
        public static Regex SchemaFilterInclude;
        public static Regex TableFilterExclude;
        public static Regex TableFilterInclude;
        public static Regex StoredProcedureFilterExclude;
        public static Regex StoredProcedureFilterInclude;
        public static Func<Table, bool> TableFilter;
        public static Func<StoredProcedure, bool> StoredProcedureFilter;
        public static Func<Table, bool> ConfigurationFilter;
        public static Dictionary<string, string> StoredProcedureReturnTypes = new Dictionary<string, string>();
        public static Regex ColumnFilterExclude;
        public static bool UseLazyLoading;
        public static string[] FilenameSearchOrder;
        public static string[] AdditionalNamespaces;
        public static string[] AdditionalContextInterfaceItems;
        public static string[] AdditionalReverseNavigationsDataAnnotations;
        public static string[] AdditionalForeignKeysDataAnnotations;
        public static string ConfigFilePath;
        public static Func<string, string, bool, string> TableRename;
        public static Func<StoredProcedure, string> StoredProcedureRename;
        public static Func<string, StoredProcedure, string> StoredProcedureReturnModelRename;
        public static Func<Column, Table, Column> UpdateColumn;
        public static Func<IList<ForeignKey>, Table, Table, bool, ForeignKey> ForeignKeyProcessing;
        public static Func<Table, Table, string, string[]> ForeignKeyAnnotationsProcessing;
        public static Func<ForeignKey, ForeignKey> ForeignKeyFilter;
        public static Func<string, ForeignKey, string, Relationship, short, string> ForeignKeyName;
        public static string MigrationConfigurationFileName;
        public static string MigrationStrategy = "MigrateDatabaseToLatestVersion";
        public static string ContextKey;
        public static bool AutomaticMigrationsEnabled;
        public static bool AutomaticMigrationDataLossAllowed;
        public static List<EnumDefinition> EnumDefinitions = new List<EnumDefinition>();
        public static Dictionary<string, string> ColumnNameToDataAnnotation;
        public static bool IncludeCodeGeneratedAttribute;
        public static Tables Tables;
        public static List<StoredProcedure> StoredProcs;

        public static Elements ElementsToGenerate;
        public static string PocoNamespace, ContextNamespace, UnitOfWorkNamespace, PocoConfigurationNamespace;

        public static float TargetFrameworkVersion;
        public static Func<string,bool> IsSupportedFrameworkVersion = (string frameworkVersion) =>
        {
            var nfi = CultureInfo.InvariantCulture.NumberFormat;
            var isSupported = float.Parse(frameworkVersion, nfi);
            return isSupported <= TargetFrameworkVersion;
        };
    };

    const string CodeGeneratedAttribute = "[System.CodeDom.Compiler.GeneratedCode(\"EF.Reverse.POCO.Generator\", \"2.36.1.0\")]";
    const string DataDirectory = "|DataDirectory|";

    static readonly List<string> NotNullable = new List<string>
    {
        "string",
        "byte[]",
        "datatable",
        "system.data.datatable",
        "object",
        "microsoft.sqlserver.types.sqlgeography",
        "microsoft.sqlserver.types.sqlgeometry",
        "system.data.entity.spatial.dbgeography",
        "system.data.entity.spatial.dbgeometry",
        "system.data.entity.hierarchy.hierarchyid"
    };

    static readonly List<string> ReservedKeywords = new List<string>
    {
        "abstract", "as", "base", "bool", "break", "byte", "case", "catch", "char",
        "checked", "class", "const", "continue", "decimal", "default", "delegate", "do",
        "double", "else", "enum", "event", "explicit", "extern", "false", "finally", "fixed",
        "float", "for", "foreach", "goto", "if", "implicit", "in", "int", "interface",
        "internal", "is", "lock", "long", "namespace", "new", "null", "object", "operator",
        "out", "override", "params", "private", "protected", "public", "readonly", "ref",
        "return", "sbyte", "sealed", "short", "sizeof", "stackalloc", "static", "string",
        "struct", "switch", "this", "throw", "true", "try", "typeof", "uint", "ulong",
        "unchecked", "unsafe", "ushort", "using", "virtual", "volatile", "void", "while"
    };

	// Obtained from Oracle docs at: https://docs.oracle.com/database/121/SQLRF/functions002.htm#SQLRF51178
	static readonly List<string> OracleBuiltInSingleRowFunctions = new List<string>
    {
        "abs", "acos", "asin", "atan", "atan2", "bitand", "ceil", "cos", "cosh", "exp", "floor",
		"ln", "log", "mod", "nanvl", "power", "remainder", "round", "sign", "sin", "sinh", "sqrt",
		"tan", "tanh", "trunc", "width_bucket", "chr", "concat", "initcap", "lower", "lpad", 
		"ltrim", "nchr", "nls_initcap", "nls_lower", "nls_upper", "nlssort", "regexp_replace",
		"regexp_substr", "replace", "rpad", "rtrim", "soundex", "substr", "translate", "trim",
		"upper", "ascii", "instr", "length", "regexp_count", "regexp_instr", "nls_charset_decl_len",
		"nls_charset_id", "nls_charset_name", "add_months", "current_date", "current_timestamp", 
		"dbtimezone", "extract", "from_tz", "last_day", "localtimestamp", "months_between",
		"new_time", "next_day", "numtodsinterval", "numtoyminterval", "ora_dst_affected", 
		"ora_dst_convert", "ora_dst_error", "sessiontimezone", "sys_extract_utc", "sysdate",
		"systimestamp", "to_char", "to_dsinterval", "to_timestamp", "to_timestamp_tz",
		"to_yminterval", "tz_offset", "greatest", "least", "asciistr", "bin_to_num", "cast", 
		"chartorowid", "compose", "convert", "decompose", "hextoraw", "rawtohex", "rawtonhex", 
		"rowidtochar", "rowidtonchar", "scn_to_timestamp", "timestamp_to_scn", "to_binary_double",
		"to_binary_float", "to_blob", "to_clob", "to_date", "to_lob", "to_multi_byte", "to_nchar",
		"to_nclob", "to_number", "to_single_byte", "treat", "unistr", "bfilename",
		"empty_blob,empty_clob", "cardinality", "collect", "powermultiset",
		"powermultiset_by_cardinality", "set", "sys_connect_by_path", "cluster_details",
		"cluster_distance", "cluster_id", "cluster_probability", "cluster_set", "feature_details",
		"feature_id", "feature_set", "feature_value", "prediction", "prediction_bounds",
		"prediction_cost", "prediction_details", "prediction_probability", "prediction_set",
		"appendchildxml", "deletexml", "depth", "existsnode", "extractvalue", "insertchildxml",
		"insertchildxmlafter", "insertchildxmlbefore", "insertxmlafter", "insertxmlbefore", "path", 
		"sys_dburigen", "sys_xmlagg", "sys_xmlgen", "updatexml", "xmlagg", "xmlcast", "xmlcdata",
		"xmlcolattval", "xmlcomment", "xmlconcat", "xmldiff", "xmlelement", "xmlexists",
		"xmlforest", "xmlisvalid", "xmlparse", "xmlpatch", "xmlpi", "xmlquery", "xmlroot",
		"xmlsequence", "xmlserialize", "xmltable", "xmltransform", "json_query", "json_table",
		"json_value", "decode", "dump", "ora_hash", "standard_hash", "vsize", "coalesce", 
		"lnnvl", "nullif", "nvl", "nvl2", "con_dbid_to_id", "con_guid_to_id", "con_name_to_id",
		"con_uid_to_id", "ora_invoking_user", "ora_invoking_userid", "sys_context", "sys_guid", 
		"sys_typeid", "uid", "user", "userenv"
    };

    private static readonly Regex RxCleanUp = new Regex(@"[^\w\d\s_-]", RegexOptions.Compiled);

    private static readonly Func<string, string> CleanUp = (str) =>
    {
        // Replace punctuation and symbols in variable names as these are not allowed.
        int len = str.Length;
        if (len == 0)
            return str;
        var sb = new StringBuilder();
        bool replacedCharacter = false;
        for(int n = 0; n < len; ++n )
        {
            char c = str[n];
            if (c != '_' && c != '-' && (char.IsSymbol(c) || char.IsPunctuation(c)))
            {
                int ascii = c;
                sb.AppendFormat("{0}", ascii);
                replacedCharacter = true;
                continue;
            }
            sb.Append(c);
        }
        if (replacedCharacter)
            str = sb.ToString();

        // Remove non alphanumerics
        str = RxCleanUp.Replace(str, "");
        if(char.IsDigit(str[0]))
            str = "C" + str;

        return str;
    };

    private static readonly Func<string, string> ToDisplayName = (str) =>
    {
        if (string.IsNullOrEmpty(str))
            return string.Empty;

        var sb = new StringBuilder();
        str = Regex.Replace(str, @"[^a-zA-Z0-9]", " "); // Anything that is not a letter or digit, convert to a space
        str = Regex.Replace(str, @"[A-Z]{2,}", " $+ "); // Any word that is upper case

        var hasUpperCased = false;
        var lastChar = '\0';
        foreach (var original in str.Trim())
        {
            var c = original;
            if (lastChar == '\0')
            {
                c = char.ToUpperInvariant(original);
            }
            else
            {
                var isLetter = char.IsLetter(original);
                var isDigit = char.IsDigit(original);
                var isWhiteSpace = !isLetter && !isDigit;

                // Is this char is different to last time
                var isDifferent = false;
                if (isLetter && !char.IsLetter(lastChar))
                    isDifferent = true;
                else if (isDigit && !char.IsDigit(lastChar))
                    isDifferent = true;
                else if (char.IsUpper(original) && !char.IsUpper(lastChar))
                    isDifferent = true;

                if (isDifferent || isWhiteSpace)
                    sb.Append(' '); // Add a space

                if (hasUpperCased && isLetter)
                    c = char.ToLowerInvariant(original);
            }
            lastChar = original;
            if (!hasUpperCased && char.IsUpper(c))
                hasUpperCased = true;
            sb.Append(c);
        }
        str = sb.ToString();
        str = Regex.Replace(str, @"\s+", " ").Trim(); // Multiple white space to one space
        str = Regex.Replace(str, @"\bid\b", "ID"); //  Make ID word uppercase
        return str;
    };

    public static void ArgumentNotNull<T>(T arg, string name) where T : class
    {
        if (arg == null)
        {
            throw new ArgumentNullException(name);
        }
    }

    private static bool IsNullable(Column col)
    {
        return col.IsNullable && !NotNullable.Contains(col.PropertyType.ToLower());
    }

    private string GetConnectionString(ref string connectionStringName, out string providerName, out string configFilePath)
    {
        providerName = null;
        configFilePath = string.Empty;
        var result = "";
        var paths = GetConfigPaths();

        // Find a configuration file with the named connection string
        foreach (var path in paths)
        {
            var configFile = new ExeConfigurationFileMap { ExeConfigFilename = path };
            var appConfig = System.Configuration.ConfigurationManager.OpenMappedExeConfiguration(configFile, ConfigurationUserLevel.None);
            var connSection = appConfig.ConnectionStrings;

            if (string.IsNullOrEmpty(connectionStringName))
                continue;

            // Get the named connection string
            try
            {
                result = connSection.ConnectionStrings[connectionStringName].ConnectionString;
                providerName = connSection.ConnectionStrings[connectionStringName].ProviderName;
                configFilePath = path;
                return result;  // found it
            }
            catch
            {
                result = "There is no connection string name called '" + connectionStringName + "'";
            }
        }
        return result;
    }

    private void InitConnectionString()
    {
        if(!string.IsNullOrEmpty(Settings.ConnectionString))
            return;

        Settings.ConnectionString = GetConnectionString(ref Settings.ConnectionStringName, out Settings.ProviderName, out Settings.ConfigFilePath);

        if(!Settings.ConnectionString.Contains(DataDirectory))
            return;

        // Replace data directory path
        var dataFilePath = GetDataDirectory();
        Settings.ConnectionString = Settings.ConnectionString.Replace(DataDirectory, dataFilePath);
    }

    public new void WriteLine(string format, params object[] args)
    {
        WriteLine(string.Format(CultureInfo.CurrentCulture, format, args));
    }

    public new void WriteLine(string message)
    {
        LogToOutput(message);
        base.WriteLine(message);
    }
	
    public new void Warning(string message)
    {
        LogToOutput(string.Format(CultureInfo.CurrentCulture, "Warning: {0}", message));
        base.Warning(message);
    }
    public new void Error(string message)
    {
        LogToOutput(string.Format(CultureInfo.CurrentCulture, "Error: {0}", message));
        base.Error(message);
    }
    private object GetCOMService(IServiceProvider provider, Type type)
    {
        object result = provider.GetService(type);
        if (result == null)
        {
            return result;
        }
        try
        {
            return System.Runtime.InteropServices.Marshal.GetObjectForIUnknown(
                System.Runtime.InteropServices.Marshal.GetIUnknownForObject(result));
        }
        catch (Exception)
        {
            return result;
        }
    }

    private void LogToOutput(string message)
    {
        var serviceProvider = GetServiceProvider();
        var dte = (DTE)GetCOMService(serviceProvider, typeof(DTE));
        var window = dte.Windows.Item(Constants.vsWindowKindOutput);
        var outputWindow = (OutputWindow) window.Object;
        outputWindow.ActivePane.Activate();
        outputWindow.ActivePane.OutputString(message);		
        outputWindow.ActivePane.OutputString("\n");
    }

    private IServiceProvider GetServiceProvider()
    {
        var serviceProvider = (IServiceProvider) Host;
        if (serviceProvider == null)
            throw new Exception("Host property returned unexpected value (null)");
        return serviceProvider;
    }

    public DTE GetDTE()
	{
		var serviceProvider = GetServiceProvider();

        var dte = (DTE)serviceProvider.GetService(typeof(DTE));
        if(dte == null)
            throw new Exception("Unable to retrieve EnvDTE.DTE");

        return dte;
    }

    public Solution GetSolution()
    {
        return GetDTE().Solution;
    }

    public IEnumerable<Project> GetAllProjects()
    {
        foreach(var projectObj in GetSolution().Projects)
        {
            var project = projectObj as Project;
            if(project == null)
                continue;
            if(project.Kind == Constants.vsProjectKindSolutionItems)
                foreach(var p in RecurseSolutionFolder(project))
                    yield return p;
            else
                yield return project;
        }
    }

    private IEnumerable<Project> RecurseSolutionFolder(Project project)
    {
        if (project.ProjectItems == null)
            yield break;

        foreach (ProjectItem projectItem in project.ProjectItems)
        {
            var subProject = projectItem.SubProject;
            if (subProject == null)
                continue;
            if (subProject.Kind == Constants.vsProjectKindSolutionItems)
            {
                foreach (var p in RecurseSolutionFolder(subProject))
                    yield return p;
            }
            else
                yield return subProject;
        }
    }

    public Project GetCurrentProject()
    {
        var dte = GetDTE();

        // Get the project item
        var projectItem = dte.Solution.FindProjectItem(Host.TemplateFile);
        // Get the project
        var currentProject = projectItem.ContainingProject;
        if (currentProject != null)
            return currentProject;

        // this returns SELECTED (active) project(s) - it may be a different project than the T4 template. Looping over dte.Solution works, but why can't we get their FullName (csproj path)?
        var activeSolutionProjects = (Array)dte.ActiveSolutionProjects;
        if(activeSolutionProjects == null)
            throw new Exception("DTE.ActiveSolutionProjects returned null");

        if (activeSolutionProjects.Length > 0)
        {
            var dteProject = (Project) activeSolutionProjects.GetValue(0);
            if (dteProject != null)
                return dteProject;
        }

        var item = dte.Solution.FindProjectItem(Host.TemplateFile);
        if (item != null && item.ContainingProject != null)
            return item.ContainingProject;

        throw new InvalidOperationException("Error in GetCurrentProject(). Unable to find project.");
    }

    private string GetProjectPath(Project project)
    {
        var fullProjectName = project.FullName;

        if (string.IsNullOrWhiteSpace(fullProjectName))
            return string.Empty;

        try
        {
            var info = new FileInfo(fullProjectName);
            return info.Directory == null ? string.Empty : info.Directory.FullName;
        }
        catch{
            WriteLine("// Project " + fullProjectName + " excluded.");
            return string.Empty;
        }
    }

    private List<string> GetConfigPaths()
    {
        var paths = new List<string>();

        // Local project first
        Project project = GetCurrentProject();
        paths.AddRange(GetConfigPathsInProject(project));

        // Then other projects next
        var projects = GetAllProjects();
        foreach (Project dteProject in projects)
        {
            paths.AddRange(GetConfigPathsInProject(dteProject));
        }

        if (!paths.Any() && Settings.FilenameSearchOrder != null)
        {
            var sln = GetSolution();
            paths.AddRange(
                Settings.FilenameSearchOrder
                .Select(sln.FindProjectItem)
                .Where(item => item != null)
                .Select(item => item.FileNames[0]));
        }

        return paths;
    }

    private List<string> GetConfigPathsInProject(Project project)
    {
        var paths = new List<string>();
        if (Settings.FilenameSearchOrder == null || project == null)
            return paths;
        foreach (string filename in Settings.FilenameSearchOrder)
        {
            paths.AddRange(GetConfigPathsInProjectForFile(project, filename));
        }
        return paths;
    }

    private List<string> GetConfigPathsInProjectForFile(Project project, string filename)
    {
        try
        {
            if (project == null || project.Kind == Constants.vsProjectKindUnmodeled)
            {
                // Project is 'unloaded'
                return new List<string>();
            }

            return (from ProjectItem item in project.ProjectItems
                    where item.Name.Equals(filename, StringComparison.InvariantCultureIgnoreCase)
                    select Path.Combine(GetProjectPath(project), item.Name))
                    .ToList();
        }
        catch (Exception)
        {
            return new List<string>();
        }
    }

    // Search for the database file
    public string GetDataDirectory()
    {
        var factory = TryGetDbProviderFactory();
        if (factory != null)
        {
            var paths = GetConfigPaths();
            paths.Add(GetSolution().FullName);
            using (var conn = factory.CreateConnection())
            {
                if(conn != null)
                {
                    foreach (var path in paths)
                    {
                        try
                        {
                            var directory = Path.GetDirectoryName(path) + "\\";
                            var connStr = Settings.ConnectionString.Replace(DataDirectory, directory);
                            conn.ConnectionString = connStr;
                            conn.Open();
                            return directory; // Successfully opened the database. Return the datapath where we found it
                        }
                        catch (Exception)
                        {
                            // Could not open the database. Eat error, and try next path
                        }
                    }
                }
            }
        }

        // Fall back to default
        var project = GetCurrentProject();
        return Path.GetDirectoryName(project.FileName) + "\\App_Data\\";
    }

    private static string ZapPassword()
    {
        var rx = new Regex("password=[^\";]*", RegexOptions.Singleline | RegexOptions.Multiline | RegexOptions.IgnoreCase);
        return rx.Replace(Settings.ConnectionString, "password=**zapped**;");
    }

    private DbProviderFactory GetDbProviderFactory()
    {
        if (Settings.TargetFrameworkVersion < 1.0f)
        {
            var project = GetCurrentProject();
            var targetFrameworkMoniker = project.Properties.Item("TargetFrameworkMoniker").Value.ToString();
            var targetFramework = new System.Runtime.Versioning.FrameworkName(targetFrameworkMoniker).Version;
            Settings.TargetFrameworkVersion = targetFramework.Major + (targetFramework.Minor * 0.1f);
        }

        InitConnectionString();

        WriteLine("// ------------------------------------------------------------------------------------------------");
        WriteLine("// This code was generated by EntityFramework Reverse POCO Generator (http://www.reversepoco.com/).");
        WriteLine("// Created by Simon Hughes (https://about.me/simon.hughes).");
        WriteLine("//");
        WriteLine("// Do not make changes directly to this file - edit the template instead.");
        WriteLine("//");
        if (Settings.IncludeConnectionSettingComments)
        {
            WriteLine("// The following connection settings were used to generate this file:");
            if (!string.IsNullOrEmpty(Settings.ConnectionStringName) && !string.IsNullOrEmpty(Settings.ConfigFilePath))
            {
                var solutionPath = Path.GetDirectoryName(GetSolution().FileName) + "\\";
                WriteLine("//     Configuration file:     \"{0}\"", Settings.ConfigFilePath.Replace(solutionPath, string.Empty));
                WriteLine("//     Connection String Name: \"{0}\"", Settings.ConnectionStringName);
            }
            WriteLine("//     Connection String:      \"{0}\"", ZapPassword());
            WriteLine("// ------------------------------------------------------------------------------------------------");
        }

        if (!string.IsNullOrEmpty(Settings.ProviderName))
        {
            try
            {
				if (Settings.ProviderName == "Oracle.ManagedDataAccess.Client")
				{
				    return new Oracle.ManagedDataAccess.Client.OracleClientFactory();
				}
				return DbProviderFactories.GetFactory(Settings.ProviderName);
                
            }
            catch (Exception x)
            {
                var error = x.Message.Replace("\r\n", "\n").Replace("\n", " ");
                Warning(string.Format("Failed to load provider \"{0}\" - {1}", Settings.ProviderName, error));
                WriteLine("");
                WriteLine("// ------------------------------------------------------------------------------------------------");
                WriteLine("// Failed to load provider \"{0}\" - {1}", Settings.ProviderName, error);
                WriteLine("// ------------------------------------------------------------------------------------------------");
                WriteLine("");
            }
        }
        else
        {
            Warning("Failed to find providerName in the connection string");
            WriteLine("");
            WriteLine("// ------------------------------------------------------------------------------------------------");
            WriteLine("//  Failed to find providerName in the connection string");
            WriteLine("// ------------------------------------------------------------------------------------------------");
            WriteLine("");
        }
        return null;
    }

    private DbProviderFactory TryGetDbProviderFactory()
    {
        try
        {
            return DbProviderFactories.GetFactory(Settings.ProviderName);
        }
        catch (Exception)
        {
            return null;
        }
    }

    private bool IsSqlCeConnection(DbConnection connection)
    {
        if(connection.GetType().Name.ToLower() == "sqlceconnection")
            return true;
        return false;
    }

    private Tables LoadTables(DbProviderFactory factory)
    {
        if(factory == null || !(Settings.ElementsToGenerate.HasFlag(Elements.Poco) ||
                                Settings.ElementsToGenerate.HasFlag(Elements.Context) ||
                                Settings.ElementsToGenerate.HasFlag(Elements.UnitOfWork) ||
                                Settings.ElementsToGenerate.HasFlag(Elements.PocoConfiguration)))
            return new Tables();

        try
        {
            using(var conn = factory.CreateConnection())
            {
                if(conn == null)
                    return new Tables();

                conn.ConnectionString = Settings.ConnectionString;
                conn.Open();

                Settings.IsSqlCe = IsSqlCeConnection(conn);

                if(Settings.IsSqlCe)
                    Settings.PrependSchemaName = false;

                var reader = new SqlServerSchemaReader(conn, factory) { Outer = this };
                var tables = reader.ReadSchema();
                var fkList = reader.ReadForeignKeys();
                reader.IdentifyForeignKeys(fkList, tables);

                foreach (var t in tables)
                {
                    if(Settings.UseDataAnnotations)
                        t.SetupDataAnnotations();
                    t.Suffix = Settings.TableSuffix;
                }

                // Work out if there are any foreign key relationship naming clashes
                reader.ProcessForeignKeys(fkList, tables, true);
                if(Settings.UseMappingTables)
                    tables.IdentifyMappingTables(fkList, true);

                // Now we know our foreign key relationships and have worked out if there are any name clashes,
                // re-map again with intelligently named relationships.
                tables.ResetNavigationProperties();

                reader.ProcessForeignKeys(fkList, tables, false);
                if(Settings.UseMappingTables)
                    tables.IdentifyMappingTables(fkList, false);

                conn.Close();
                return tables;
            }
        }
        catch(Exception x)
        {
            string error = (x.Message + x.StackTrace).Replace("\r\n", "\n").Replace("\n", " ");
            Warning(string.Format("Failed to read database schema - {0}", error));
            WriteLine("");
            WriteLine("// -----------------------------------------------------------------------------------------");
            WriteLine("// Failed to read database schema in LoadTables() - {0}", error);
            WriteLine("// -----------------------------------------------------------------------------------------");
            WriteLine("");
            return new Tables();
        }
    }


    private List<StoredProcedure> LoadStoredProcs(DbProviderFactory factory)
    {
        if(factory == null || !Settings.IncludeStoredProcedures)
            return new List<StoredProcedure>();

        try
        {
            using(var conn = factory.CreateConnection())
            {
                if(conn == null)
                    return new List<StoredProcedure>();

                conn.ConnectionString = Settings.ConnectionString;
                conn.Open();

                if (Settings.IsSqlCe)
                    return new List<StoredProcedure>();

                var reader = new SqlServerSchemaReader(conn, factory) { Outer = this };
                var storedProcs = reader.ReadStoredProcs();
                conn.Close();

                // Remove unrequired stored procs
                for(int i = storedProcs.Count - 1; i >= 0; i--)
                {
                    if(Settings.SchemaFilterInclude != null && !Settings.SchemaFilterInclude.IsMatch(storedProcs[i].Schema))
                    {
                        storedProcs.RemoveAt(i);
                        continue;
                    }
                    if(Settings.StoredProcedureFilterInclude != null && !Settings.StoredProcedureFilterInclude.IsMatch(storedProcs[i].Name))
                    {
                        storedProcs.RemoveAt(i);
                        continue;
                    }
                    if(!Settings.StoredProcedureFilter(storedProcs[i]))
                    {
                        storedProcs.RemoveAt(i);
                        continue;
                    }
                }

                using (var sqlConnection = new SqlConnection(Settings.ConnectionString))
                {
                    foreach (var proc in storedProcs)
                        reader.ReadStoredProcReturnObject(sqlConnection, proc);
                }

                // Remove stored procs where the return model type contains spaces and cannot be mapped
                // Also need to remove any TVF functions with parameters that are non scalar types, such as DataTable
                var validStoredProcedures = new List<StoredProcedure>();
                foreach (var sp in storedProcs)
                {
                    if (!sp.ReturnModels.Any())
                    {
                        validStoredProcedures.Add(sp);
                        continue;
                    }

                    if (sp.ReturnModels.Any(returnColumns => returnColumns.Any(c => c.ColumnName.Contains(" "))))
                        continue;

                    if (sp.IsTVF && sp.Parameters.Any(c => c.PropertyType == "System.Data.DataTable"))
                        continue;

                    validStoredProcedures.Add(sp);
                }
                return validStoredProcedures;
            }
        }
        catch(Exception x)
        {
            var error = x.Message.Replace("\r\n", "\n").Replace("\n", " ");
            Warning(string.Format("Failed to read database schema for stored procedures - {0}", error));
            WriteLine("");
            WriteLine("// -----------------------------------------------------------------------------------------");
            WriteLine("// Failed to read database schema for stored procedures - {0}", error);
            WriteLine("// -----------------------------------------------------------------------------------------");
            WriteLine("");
            return new List<StoredProcedure>();
        }
    }

    public enum Relationship
    {
        OneToOne,
        OneToMany,
        ManyToOne,
        ManyToMany,
        DoNotUse
    }

    // Calculates the relationship between a child table and it's parent table.
    public static Relationship CalcRelationship(Table parentTable, Table childTable, List<Column> childTableCols, List<Column> parentTableCols)
    {
        if (childTableCols.Count == 1 && parentTableCols.Count == 1)
            return CalcRelationshipSingle(parentTable, childTable, childTableCols.First(), parentTableCols.First());

        // This relationship has multiple composite keys

        // childTable FK columns are exactly the primary key (they are part of primary key, and no other columns are primary keys) //TODO: we could also check if they are an unique index
        bool childTableColumnsAllPrimaryKeys = (childTableCols.Count == childTableCols.Count(x => x.IsPrimaryKey)) && (childTableCols.Count == childTable.PrimaryKeys.Count());

        // parentTable columns are exactly the primary key (they are part of primary key, and no other columns are primary keys) //TODO: we could also check if they are an unique index
        bool parentTableColumnsAllPrimaryKeys = (parentTableCols.Count == parentTableCols.Count(x => x.IsPrimaryKey)) && (parentTableCols.Count == parentTable.PrimaryKeys.Count());

        // childTable FK columns are not only FK but also the whole PK (not only part of PK); parentTable columns are the whole PK (not only part of PK) - so it's 1:1
        if(childTableColumnsAllPrimaryKeys && parentTableColumnsAllPrimaryKeys)
            return Relationship.OneToOne;

        return Relationship.ManyToOne;
    }

    // Calculates the relationship between a child table and it's parent table.
    public static Relationship CalcRelationshipSingle(Table parentTable, Table childTable, Column childTableCol, Column parentTableCol)
    {
        if(!childTableCol.IsPrimaryKey && !childTableCol.IsUniqueConstraint)
            return Relationship.ManyToOne;

        if(!parentTableCol.IsPrimaryKey && !parentTableCol.IsUniqueConstraint)
            return Relationship.ManyToOne;

        if (childTable.PrimaryKeys.Count() != 1)
            return Relationship.ManyToOne;

        if (parentTable.PrimaryKeys.Count() != 1)
            return Relationship.ManyToOne;

        return Relationship.OneToOne;
    }

    public class EnumDefinition
    {
        public string Schema;
        public string Table;
        public string Column;
        public string EnumType;
    }

    #region Nested type: Column

    public class PropertyAndComments
    {
        public string Definition;
        public string Comments;
        public string[] AdditionalDataAnnotations;
    }

    public class Column
    {
        public string Name; // Raw name of the column as obtained from the database
        public string NameHumanCase; // Name adjusted for C# output
        public string DisplayName;  // Name used in the data annotation [Display(Name = "<DisplayName> goes here")]
        public bool  OverrideModifier = false; // Adds 'override' to the property declaration

        public int DateTimePrecision;
        public string Default;
        public int MaxLength;
        public int Precision;
        public string SqlPropertyType;
        public string PropertyType;
        public int Scale;
        public int Ordinal;
        public int PrimaryKeyOrdinal;
        public string ExtendedProperty;
        public string SummaryComments;
        public string UniqueIndexName;

        public bool IsIdentity;
        public bool IsNullable;
        public bool IsPrimaryKey;
        public bool IsUniqueConstraint;
        public bool IsUnique;
        public bool IsStoreGenerated;
        public bool IsRowVersion;
        public bool IsConcurrencyToken; //  Manually set via callback
        public bool IsFixedLength;
        public bool IsUnicode;
        public bool IsMaxLength;
        public bool Hidden;
        public bool IsForeignKey;

        public string Config;
        public List<string> ConfigFk = new List<string>();
        public string Entity;
        public List<PropertyAndComments> EntityFk = new List<PropertyAndComments>();

        public List<string> DataAnnotations;
        public List<Index> Indexes = new List<Index>();

        public Table ParentTable;

        public void ResetNavigationProperties()
        {
            ConfigFk = new List<string>();
            EntityFk = new List<PropertyAndComments>();
        }

        private void SetupEntity()
        {
            var comments = string.Empty;
            if (Settings.IncludeComments != CommentsStyle.None)
            {
                comments = Name;
                if (IsPrimaryKey)
                {
                    if (IsUniqueConstraint)
                        comments += " (Primary key via unique index " + UniqueIndexName + ")";
                    else
                        comments += " (Primary key)";
                }

                if (MaxLength > 0)
                    comments += string.Format(" (length: {0})", MaxLength);
            }

            var inlineComments = Settings.IncludeComments == CommentsStyle.AtEndOfField ? " // " + comments : string.Empty;

            SummaryComments = string.Empty;
            if (Settings.IncludeComments == CommentsStyle.InSummaryBlock && !string.IsNullOrEmpty(comments))
            {
                SummaryComments = comments;
            }
            if (Settings.IncludeExtendedPropertyComments == CommentsStyle.InSummaryBlock && !string.IsNullOrEmpty(ExtendedProperty))
            {
                if (string.IsNullOrEmpty(SummaryComments))
                    SummaryComments = ExtendedProperty;
                else
                    SummaryComments += ". " + ExtendedProperty;
            }

            if (Settings.IncludeExtendedPropertyComments == CommentsStyle.AtEndOfField && !string.IsNullOrEmpty(ExtendedProperty))
            {
                if (string.IsNullOrEmpty(inlineComments))
                    inlineComments = " // " + ExtendedProperty;
                else
                    inlineComments += ". " + ExtendedProperty;
            }
            var initialization = Settings.UsePropertyInitializers ? (Default == string.Empty ? "" : string.Format(" = {0};", Default)) : "";
            Entity = string.Format("public {0}{1} {2} {{ get; {3}set; }}{4}{5}", (OverrideModifier ? "override " : ""), WrapIfNullable(PropertyType, this), NameHumanCase, Settings.UsePrivateSetterForComputedColumns && IsComputed() ? "private " : string.Empty, initialization, inlineComments);
        }

        private string WrapIfNullable(string propType, Column col)
        {
            if(!IsNullable(col))
                return propType;
            return string.Format(Settings.NullableShortHand ? "{0}?" : "System.Nullable<{0}>",propType);
        }

        private bool IsComputed()
        {
            return IsStoreGenerated && !IsIdentity;
        }

        private void SetupConfig()
        {
            DataAnnotations = new List<string>();
            string databaseGeneratedOption = null;
            var schemaReference = Settings.UseDataAnnotations
                ? string.Empty
                : "System.ComponentModel.DataAnnotations.Schema.";

            bool isNewSequentialId = !string.IsNullOrEmpty(Default)  && Default.ToLower().Contains("newsequentialid");

            if (IsIdentity || isNewSequentialId)
            {
                if(Settings.UseDataAnnotations || isNewSequentialId)
                    DataAnnotations.Add("DatabaseGenerated(DatabaseGeneratedOption.Identity)");
                else
                    databaseGeneratedOption = string.Format(".HasDatabaseGeneratedOption({0}DatabaseGeneratedOption.Identity)", schemaReference);
            }
            else if(IsComputed())
            {
                if(Settings.UseDataAnnotations)
                    DataAnnotations.Add("DatabaseGenerated(DatabaseGeneratedOption.Computed)");
                else
                    databaseGeneratedOption = string.Format(".HasDatabaseGeneratedOption({0}DatabaseGeneratedOption.Computed)", schemaReference);
            }
            else if (IsPrimaryKey)
            {
                if(Settings.UseDataAnnotations)
                    DataAnnotations.Add("DatabaseGenerated(DatabaseGeneratedOption.None)");
                else
                    databaseGeneratedOption = string.Format(".HasDatabaseGeneratedOption({0}DatabaseGeneratedOption.None)", schemaReference);
            }

            var sb = new StringBuilder();

            if(Settings.UseDataAnnotations)
                DataAnnotations.Add(string.Format("Column(@\"{0}\", Order = {1}, TypeName = \"{2}\")", Name, Ordinal, SqlPropertyType));
            else
                sb.AppendFormat(".HasColumnName(@\"{0}\").HasColumnType(\"{1}\")", Name, SqlPropertyType);

            if (Settings.UseDataAnnotations && Indexes.Any())
            {
                foreach (var index in Indexes)
                {
                    DataAnnotations.Add(string.Format("Index(@\"{0}\", {1}, IsUnique = {2}, IsClustered = {3})",
                        index.IndexName,
                        index.KeyOrdinal,
                        index.IsUnique ? "true" : "false",
                        index.IsClustered ? "true" : "false"));
                }
            }

            if (IsNullable)
            {
                sb.Append(".IsOptional()");
            }
            else
            {
                if (Settings.UseDataAnnotations)
                {
                    if(!IsComputed())
                        DataAnnotations.Add("Required");
                }
                else
                    sb.Append(".IsRequired()");
            }

            if (IsFixedLength || IsRowVersion)
            {
                sb.Append(".IsFixedLength()");
                // DataAnnotations.Add("????");
            }

            if (!IsUnicode)
            {
                sb.Append(".IsUnicode(false)");
                // DataAnnotations.Add("????");
            }

            if (!IsMaxLength && MaxLength > 0)
            {
                var doNotSpecifySize = (Settings.IsSqlCe && MaxLength > 4000); // Issue #179

                if (Settings.UseDataAnnotations)
                {
                    DataAnnotations.Add(doNotSpecifySize ? "MaxLength" : string.Format("MaxLength({0})", MaxLength));

                    if (PropertyType.Equals("string", StringComparison.InvariantCultureIgnoreCase))
                        DataAnnotations.Add(string.Format("StringLength({0})", MaxLength));
                }
                else
                {
                    if (doNotSpecifySize)
                        sb.Append(".HasMaxLength(null)");
                    else
                        sb.AppendFormat(".HasMaxLength({0})", MaxLength);
                }
            }

            if (IsMaxLength)
            {
                if (Settings.UseDataAnnotations)
                    DataAnnotations.Add("MaxLength");
                else
                    sb.Append(".IsMaxLength()");
            }

            if ((Precision > 0 || Scale > 0) && PropertyType == "decimal")
            {
                sb.AppendFormat(".HasPrecision({0},{1})", Precision, Scale);
                // DataAnnotations.Add("????");
            }

            if (IsRowVersion)
            {
                if (Settings.UseDataAnnotations)
                    DataAnnotations.Add("Timestamp");
                else
                    sb.Append(".IsRowVersion()");
            }

            if (IsConcurrencyToken)
            {
                sb.Append(".IsConcurrencyToken()");
                // DataAnnotations.Add("????");
            }

            if(databaseGeneratedOption != null)
                sb.Append(databaseGeneratedOption);

            var config = sb.ToString();
            if(!string.IsNullOrEmpty(config))
                Config = string.Format("Property(x => x.{0}){1};", NameHumanCase, config);

            if (!Settings.UseDataAnnotations)
                return; // Only data annotations below this point

            if (IsPrimaryKey)
                DataAnnotations.Add("Key");

            string value;
            if(Settings.ColumnNameToDataAnnotation.TryGetValue(NameHumanCase.ToLowerInvariant(), out value))
                DataAnnotations.Add(value);

            DataAnnotations.Add(string.Format("Display(Name = \"{0}\")", DisplayName));
        }

        public void SetupEntityAndConfig()
        {
            SetupEntity();
            SetupConfig();
        }

        public void CleanUpDefault()
        {
            if (string.IsNullOrWhiteSpace(Default))
            {
                Default = string.Empty;
                return;
            }

            // Remove outer parenthesis
            while (Default.First() == '(' && Default.Last() == ')' && Default.Length > 2)
            {
                Default = Default.Substring(1, Default.Length - 2);
            }

            // Remove unicode prefix
			// NL: Not needed for Oracle
            // if (IsUnicode && Default.StartsWith("N") && !Default.Equals("NULL", StringComparison.InvariantCultureIgnoreCase))
            //     Default = Default.Substring(1, Default.Length - 1);

			// Remove leading and traling single-quote
            if(Default.First() == '\'' && Default.Last() == '\'' && Default.Length >= 2)
                Default = string.Format("\"{0}\"", Default.Substring(1, Default.Length - 2));

			// Sanitize single-quote pairs: ''this is text'' to 'this is text'
			Default = Default.Replace("\'\'", "\'");

            string lower = Default.ToLower();
            string lowerPropertyType = PropertyType.ToLower();

            // Cleanup default
            switch(lowerPropertyType)
            {
				// TODO: NL - handle PL/SQL dataypes
				case "string":
                case "system.datetime":
                case "system.datetimeoffset":
                    if(Default.First() != '"')
                        Default = string.Format("\"{0}\"", Default);
                    if(Default.Contains('\\') || Default.Contains('\r') || Default.Contains('\n'))
                        Default = "@" + Default;
                    else
                        Default = string.Format("\"{0}\"", Default.Substring(1, Default.Length - 2).Replace("\"", "\\\"")); // #281 Default values must be escaped if contain double quotes
                    break;
                case "long":
                case "short":
                case "int":
				case "double":
                case "float":
                case "decimal":
                    if(Default.First() == '\"' && Default.Last() == '\"' && Default.Length > 2)
                        Default = Default.Substring(1, Default.Length - 2);
                    break;
				case "byte[]":
                    Default = string.Empty;
                    break;
            }

            // Ignore defaults we cannot interpret (we would need SQL to C# compiler)
			// The following regex will match any of the builtin function names followed by an opening parenthsis. For example, it will match the following:
			// to_char(sysdate)
			// to_char     (sysdate)
			// to_char   \n  (sysdate)
            if (OracleBuiltInSingleRowFunctions.Any(f => System.Text.RegularExpressions.Regex.IsMatch(lower, String.Format(@"{0}\s*\(.*", f))))
            {
                Default = string.Empty;
                return;
            }

            if(string.IsNullOrWhiteSpace(Default))
            {
                Default = string.Empty;
                return;
            }

            // Validate default
            switch(lowerPropertyType)
            {
                case "long":
                    long l;
                    if(!long.TryParse(Default, out l))
                        Default = string.Empty;
                    break;

                case "short":
                    short s;
                    if(!short.TryParse(Default, out s))
                        Default = string.Empty;
                    break;

                case "int":
                    int i;
                    if(!int.TryParse(Default, out i))
                        Default = string.Empty;
                    break;

                case "system.datetime":
                    DateTime dt;
                    if(!DateTime.TryParse(Default, out dt))
                        Default = (lower == "sysdate" || lower == "systimestamp") ? "System.DateTime.Now" : string.Empty;
                    else
                        Default = string.Format("System.DateTime.Parse({0})", Default);
                    break;

                case "system.datetimeoffset":
                    DateTimeOffset dto;
                    if(!DateTimeOffset.TryParse(Default, out dto))
                        Default = lower == "systimestamp" ? "System.DateTimeOffset.Now" : string.Empty;
                    else
                        Default = string.Format("System.DateTimeOffset.Parse({0})", Default);
                    break;

                case "decimal":
                    decimal dec;
                    if (!decimal.TryParse(Default, out dec))
                        Default = string.Empty;
                    else
                        Default += "m";
                    break;

				case "float":
                    float fl;
                    if (!float.TryParse(Default, out fl))
                        Default = string.Empty;
                    else
                        Default += "f";
                    break;

				case "double":
                    double d;
                    if (!double.TryParse(Default, out d))
                        Default = string.Empty;
                    else
                        Default += "d";
                    break;

                case "string":
                    // if(lower.StartsWith("space("))
                    //     Default = "\"\"";
                    if(lower == "null")
                        Default = string.Empty;
                    break;
            }
        }
    }

    #endregion

    #region Nested type: Stored Procedure

    public class StoredProcedure
    {
        public string Schema;
        public string Name;
        public string NameHumanCase;
        public List<StoredProcedureParameter> Parameters;
        public List<List<DataColumn>> ReturnModels;    // A list of return models, containing a list of return columns
        public bool IsTVF;

        public StoredProcedure()
        {
            Parameters = new List<StoredProcedureParameter>();
            ReturnModels = new List<List<DataColumn>>();
        }

        public static bool IsNullable(DataColumn col)
        {
            return col.AllowDBNull &&
                   !(NotNullable.Contains(col.DataType.Name.ToLower())
                   || NotNullable.Contains(col.DataType.Namespace.ToLower() + "." + col.DataType.Name.ToLower()));
        }

        public static string WrapTypeIfNullable(string propertyType, DataColumn col) {
            if(!IsNullable(col))
                return propertyType;
            return string.Format(Settings.NullableShortHand ? "{0}?" : "System.Nullable<{0}>",propertyType);
        }

    }

    public enum StoredProcedureParameterMode
    {
        In,
        InOut,
        Out
    };

    public class StoredProcedureParameter
    {
        public int Ordinal;
        public StoredProcedureParameterMode Mode;
        public string Name;
        public string NameHumanCase;
        public string SqlDbType;
        public string PropertyType;
        public string UserDefinedTypeName;
        public int DateTimePrecision;
        public int MaxLength;
        public int Precision;
        public int Scale;
    }

    #endregion

    #region Nested type: Inflector

    /// <summary>
    /// Summary for the Inflector class
    /// </summary>
    public static class Inflector
    {
        public static IPluralizationService PluralizationService = null;

        /// <summary>
        /// Makes the plural.
        /// </summary>
        /// <param name="word">The word.</param>
        /// <returns></returns>
        public static string MakePlural(string word)
        {
            try
            {
                if (string.IsNullOrEmpty(word))
                    return string.Empty;
                if(PluralizationService == null)
                    return word;

                if (word.Contains('_')) return MakePluralHelper(word, '_');
                if (word.Contains(' ')) return MakePluralHelper(word, ' ');
                if (word.Contains('-')) return MakePluralHelper(word, '-');

                return PluralizationService.Pluralize(word);
            }
            catch (Exception)
            {
                return word;
            }
        }

        private static string MakePluralHelper(string word, char split)
        {
            if (string.IsNullOrEmpty(word))
                return string.Empty;
            var parts = word.Split(split);
            parts[parts.Length - 1] = PluralizationService.Pluralize(parts[parts.Length - 1]); // Pluralize just the last word
            return string.Join(split.ToString(), parts);
        }

        /// <summary>
        /// Makes the singular.
        /// </summary>
        /// <param name="word">The word.</param>
        /// <returns></returns>
        public static string MakeSingular(string word)
        {
            try
            {
                if (string.IsNullOrEmpty(word))
                    return string.Empty;

                if(PluralizationService == null)
                    return word;

                if (word.Contains('_')) return MakeSingularHelper(word, '_');
                if (word.Contains(' ')) return MakeSingularHelper(word, ' ');
                if (word.Contains('-')) return MakeSingularHelper(word, '-');

                return PluralizationService.Singularize(word);
            }
            catch (Exception)
            {
                return word;
            }
        }

        private static string MakeSingularHelper(string word, char split)
        {
            if (string.IsNullOrEmpty(word))
                return string.Empty;
            var parts = word.Split(split);
            parts[parts.Length - 1] = PluralizationService.Singularize(parts[parts.Length - 1]); // Pluralize just the last word
            return string.Join(split.ToString(), parts);
        }

        /// <summary>
        /// Converts the string to title case.
        /// </summary>
        /// <param name="word">The word.</param>
        /// <returns></returns>
        public static string ToTitleCase(string word)
        {
            if (string.IsNullOrEmpty(word))
                return string.Empty;

            var s = Regex.Replace(ToHumanCase(AddUnderscores(word)), @"\b([a-z])", match => match.Captures[0].Value.ToUpperInvariant());
            var digit = false;
            var sb = new StringBuilder();
            foreach (var c in s)
            {
                if (char.IsDigit(c))
                {
                    digit = true;
                    sb.Append(c);
                }
                else
                {
                    if (digit && char.IsLower(c))
                        sb.Append(char.ToUpperInvariant(c));
                    else
                        sb.Append(c);
                    digit = false;
                }
            }
            return sb.ToString();
        }

        /// <summary>
        /// Converts the string to human case.
        /// </summary>
        /// <param name="lowercaseAndUnderscoredWord">The lowercase and underscored word.</param>
        /// <returns></returns>
        public static string ToHumanCase(string lowercaseAndUnderscoredWord)
        {
            if (string.IsNullOrEmpty(lowercaseAndUnderscoredWord))
                return string.Empty;
            return MakeInitialCaps(Regex.Replace(lowercaseAndUnderscoredWord, @"_", " "));
        }


        /// <summary>
        /// Adds the underscores.
        /// </summary>
        /// <param name="pascalCasedWord">The pascal cased word.</param>
        /// <returns></returns>
        public static string AddUnderscores(string pascalCasedWord)
        {
            if (string.IsNullOrEmpty(pascalCasedWord))
                return string.Empty;
            return Regex.Replace(Regex.Replace(Regex.Replace(pascalCasedWord, @"([A-Z]+)([A-Z][a-z])", "$1_$2"), @"([a-z\d])([A-Z])", "$1_$2"), @"[-\s]", "_").ToLowerInvariant();
        }

        /// <summary>
        /// Makes the initial caps.
        /// </summary>
        /// <param name="word">The word.</param>
        /// <returns></returns>
        public static string MakeInitialCaps(string word)
        {
            if (string.IsNullOrEmpty(word))
                return string.Empty;
            return string.Concat(word.Substring(0, 1).ToUpperInvariant(), word.Substring(1).ToLowerInvariant());
        }

        /// <summary>
        /// Makes the initial character lowercase.
        /// </summary>
        /// <param name="word">The word.</param>
        /// <returns></returns>
        public static string MakeInitialLower(string word)
        {
            if (string.IsNullOrEmpty(word))
                return string.Empty;
            return string.Concat(word.Substring(0, 1).ToLowerInvariant(), word.Substring(1));
        }

        public static string MakeLowerIfAllCaps(string word)
        {
            if (string.IsNullOrEmpty(word))
                return string.Empty;
            return IsAllCaps(word) ? word.ToLowerInvariant() : word;
        }

        public static bool IsAllCaps(string word)
        {
            if (string.IsNullOrEmpty(word))
                return false;
            return word.All(char.IsUpper);
        }
    }

    #endregion

    private abstract class SchemaReader
    {
        protected readonly DbCommand Cmd;

        protected SchemaReader(DbConnection connection, DbProviderFactory factory)
        {
            Cmd = factory.CreateCommand();
            if(Cmd != null) 
			{
                Cmd.Connection = connection;
				((Oracle.ManagedDataAccess.Client.OracleCommand)Cmd).InitialLONGFetchSize = -1; // Necessary to fetch the default values
			}
        }

        public GeneratedTextTransformation Outer;
        public abstract Tables ReadSchema();
        public abstract List<StoredProcedure> ReadStoredProcs();
        public abstract List<ForeignKey> ReadForeignKeys();
        public abstract void ProcessForeignKeys(List<ForeignKey> fkList, Tables tables, bool checkForFkNameClashes);
        public abstract void IdentifyForeignKeys(List<ForeignKey> fkList, Tables tables);
        public abstract void ReadIndexes(Tables tables);
        public abstract void ReadExtendedProperties(Tables tables, bool includeConnectionSettingComments, bool commentsInSummaryBlock);

        protected void WriteLine(string o)
        {
            Outer.WriteLine(o);
        }

        protected bool IsFilterExcluded(Regex filterExclude, Regex filterInclude, string name)
        {
            if(filterExclude != null && filterExclude.IsMatch(name))
                return true;
            if(filterInclude != null && !filterInclude.IsMatch(name))
                return true;
            if (name.Contains('.'))    // EF does not allow tables to contain a period character
                return true;
            return false;
        }
    }

    private class SqlServerSchemaReader : SchemaReader
    {
        private const string TableSQL = @"
select 
t.owner as ""SchemaName"",
t.table_name as ""TableName"",
'BASE_TABLE' as ""TableType"",
nvl(c.column_id, 0) as ""Ordinal"",
c.column_name as ""ColumnName"",
decode(c.nullable, 'Y', 1, 0) as ""IsNullable"",
c.data_type ,
case 
	when c.data_type like 'INTERVAL YEAR% TO MONTH' then 'INTERVAL YEAR TO MONTH'
    when c.data_type like 'INTERVAL DAY% TO SECOND%' then 'INTERVAL DAY TO SECOND'
    when c.data_type like 'TIMESTAMP% WITH LOCAL TIME ZONE' then 'TIMESTAMP WITH LOCAL TIME ZONE'
    when c.data_type like 'TIMESTAMP% WITH TIME ZONE' then 'TIMESTAMP WITH TIME ZONE'
    when c.data_type like 'TIMESTAMP%' then 'TIMESTAMP'
    else c.data_type 
end as ""TypeName"",
cast(nvl(case 
    when c.data_type in ('CHAR', 'NCHAR', 'VARCHAR2', 'NVARCHAR2') then c.data_length
    else 0
end, 0) as int) as ""MaxLength"",
cast(nvl(c.data_precision, 0) as int) as ""Precision"",
c.data_default as ""Default"",
cast(nvl(case
    when c.data_type LIKE 'TIMESTAMP%' then c.data_scale
    else 0
end,0) as int) as ""DateTimePrecision"",
cast(nvl(case
    when c.data_type LIKE 'TIMESTAMP%' or c.data_type ='DATE' then 0     
    else c.data_scale
end,0) as int) as ""Scale"",
0 as ""IsIdentity"",
0 as ""IsStoreGenerated"",
decode(pk.column_name, null, 0, 1) as ""PrimaryKey"",
nvl(pk.position, 0) as ""PrimaryKeyOrdinal"",
decode(fk.column_name, null, 0, 1) as ""IsForeignKey""
from 
all_tables t 
inner join all_tab_cols c on c.owner = t.owner and c.table_name = t.table_name
left join (
    select 
    pk.owner,
    pk.constraint_name,
    pk.table_name,
    pkc.column_name,
    pkc.position
    from 
    all_constraints pk
    inner join all_cons_columns pkc on pkc.owner = pk.owner and pkc.constraint_name = pk.constraint_name and pkc.table_name = pk.table_name
    where 1=1
    and constraint_type = 'P'
) pk on 1=1
    and pk.owner = c.owner 
    and pk.owner = t.owner
    and pk.table_name = c.table_name 
    and pk.table_name = t.table_name
    and pk.column_name = c.column_name
left join (
    select 
    fk.owner,
    fk.constraint_name,
    fk.table_name,
    fkc.column_name,
    fkc.position
    from 
    all_constraints fk
    inner join all_cons_columns fkc on fkc.owner = fk.owner and fkc.constraint_name = fk.constraint_name and fkc.table_name = fk.table_name
    where 1=1
    and constraint_type = 'R'
) fk on 1=1
    and fk.owner = c.owner 
    and fk.owner = t.owner
    and fk.table_name = c.table_name 
    and fk.table_name = t.table_name
    and fk.column_name = c.column_name
where 1=1
and c.data_type not in (
    'LONG'
)
union all
select 
t.owner as ""SchemaName"",
t.view_name as ""TableName"",
'VIEW' as ""TableType"",
nvl(c.column_id, 0) as ""Ordinal"",
c.column_name as ""ColumnName"",
decode(c.nullable, 'Y', 1, 0) as ""IsNullable"",
c.data_type ,
case
	when c.data_type like 'INTERVAL YEAR% TO MONTH' then 'INTERVAL YEAR TO MONTH'
    when c.data_type like 'INTERVAL DAY% TO SECOND%' then 'INTERVAL DAY TO SECOND'
    when c.data_type like 'TIMESTAMP% WITH LOCAL TIME ZONE' then 'TIMESTAMP WITH LOCAL TIME ZONE'
    when c.data_type like 'TIMESTAMP% WITH TIME ZONE' then 'TIMESTAMP WITH TIME ZONE'
    when c.data_type like 'TIMESTAMP%' then 'TIMESTAMP'
    else c.data_type 
end as ""TypeName"",
cast(nvl(case 
    when c.data_type in ('CHAR', 'NCHAR', 'VARCHAR2', 'NVARCHAR2') then c.data_length
    else 0
end, 0) as int) as ""MaxLength"",
cast(nvl(c.data_precision, 0) as int) as ""Precision"",
c.data_default as ""Default"",
cast(nvl(case
    when c.data_type LIKE 'TIMESTAMP%' then c.data_scale     
    else 0
end,0) as int) as ""DateTimePrecision"",
cast(nvl(case
    when c.data_type LIKE 'TIMESTAMP%' or c.data_type ='DATE' then 0     
    else c.data_scale
end,0) as int) as ""Scale"",
0 as ""IsIdentity"",
0 as ""IsStoreGenerated"",
0 as ""PrimaryKey"",
0 as ""PrimaryKeyOrdinal"",
0 as ""IsForeignKey""
from 
all_views t
inner join all_tab_cols c on c.owner = t.owner and c.table_name = t.view_name
where 1=1
and c.data_type not in (
    'LONG'
)
";

            private const string ForeignKeySQL = @"
select
cr.table_name as ""FK_Table"",
ccr.column_name as ""FK_Column"",
pk.table_name as ""PK_Table"",
pkc.column_name as ""PK_Column"",
cr.constraint_name as ""Constraint_Name"",
cr.owner as ""fkSchema"",
pk.owner as ""pkSchema"",
pkc.column_name as ""primarykey"",
ccr.position as ""ORDINAL_POSITION"",
decode(cr.delete_rule, 'CASCADE', 1, 0) as ""CascadeOnDelete"",
decode(cr.status, 'ENABLED', 0, 1) as ""IsNotEnforced""
from 
all_constraints cr
inner join all_cons_columns ccr on ccr.owner = cr.owner and ccr.constraint_name = cr.constraint_name and ccr.table_name = cr.table_name
inner join all_constraints pk on pk.owner = cr.r_owner and PK.CONSTRAINT_NAME = cr.r_constraint_name 
inner join all_cons_columns pkc on pkc.owner = pk.owner and pkc.constraint_name = pk.constraint_name and pkc.table_name = pk.table_name and pkc.position = ccr.position
where 1=1
and cr.constraint_type in('R')
";

            private const string StoredProcedureSQL = @"
SELECT  R.SPECIFIC_SCHEMA,
        R.SPECIFIC_NAME,
        R.ROUTINE_TYPE,
        P.ORDINAL_POSITION,
        P.PARAMETER_MODE,
        P.PARAMETER_NAME,
        P.DATA_TYPE,
        ISNULL(P.CHARACTER_MAXIMUM_LENGTH, 0) AS CHARACTER_MAXIMUM_LENGTH,
        ISNULL(P.NUMERIC_PRECISION, 0) AS NUMERIC_PRECISION,
        ISNULL(P.NUMERIC_SCALE, 0) AS NUMERIC_SCALE,
        ISNULL(P.DATETIME_PRECISION, 0) AS DATETIME_PRECISION,
        P.USER_DEFINED_TYPE_SCHEMA + '.' + P.USER_DEFINED_TYPE_NAME AS USER_DEFINED_TYPE
FROM    INFORMATION_SCHEMA.ROUTINES R
        LEFT OUTER JOIN INFORMATION_SCHEMA.PARAMETERS P
            ON P.SPECIFIC_SCHEMA = R.SPECIFIC_SCHEMA
               AND P.SPECIFIC_NAME = R.SPECIFIC_NAME
WHERE   R.ROUTINE_TYPE = 'PROCEDURE'
        AND (
             P.IS_RESULT = 'NO'
             OR P.IS_RESULT IS NULL
            )
        AND R.SPECIFIC_SCHEMA + R.SPECIFIC_NAME IN (
            SELECT  SCHEMA_NAME(sp.schema_id) + sp.name
            FROM    sys.all_objects AS sp
                    LEFT OUTER JOIN sys.all_sql_modules AS sm
                        ON sm.object_id = sp.object_id
            WHERE   sp.type = 'P'
                    AND (CAST(CASE WHEN sp.is_ms_shipped = 1 THEN 1
                                   WHEN (
                                         SELECT major_id
                                         FROM   sys.extended_properties
                                         WHERE  major_id = sp.object_id
                                                AND minor_id = 0
                                                AND class = 1
                                                AND name = N'microsoft_database_tools_support'
                                        ) IS NOT NULL THEN 1
                                   ELSE 0
                              END AS BIT) = 0))

UNION ALL
SELECT  R.SPECIFIC_SCHEMA,
        R.SPECIFIC_NAME,
        R.ROUTINE_TYPE,
        P.ORDINAL_POSITION,
        P.PARAMETER_MODE,
        P.PARAMETER_NAME,
        P.DATA_TYPE,
        ISNULL(P.CHARACTER_MAXIMUM_LENGTH, 0) AS CHARACTER_MAXIMUM_LENGTH,
        ISNULL(P.NUMERIC_PRECISION, 0) AS NUMERIC_PRECISION,
        ISNULL(P.NUMERIC_SCALE, 0) AS NUMERIC_SCALE,
        ISNULL(P.DATETIME_PRECISION, 0) AS DATETIME_PRECISION,
        P.USER_DEFINED_TYPE_SCHEMA + '.' + P.USER_DEFINED_TYPE_NAME AS USER_DEFINED_TYPE
FROM    INFORMATION_SCHEMA.ROUTINES R
        LEFT OUTER JOIN INFORMATION_SCHEMA.PARAMETERS P
            ON P.SPECIFIC_SCHEMA = R.SPECIFIC_SCHEMA
               AND P.SPECIFIC_NAME = R.SPECIFIC_NAME
WHERE   R.ROUTINE_TYPE = 'FUNCTION'
        AND R.DATA_TYPE = 'TABLE'";

        private const string IndexSQL = @"
		select
i.table_owner as ""TableSchema"",
i.table_name as ""TableName"",
i.index_name as ""IndexName"",
ic.column_position as ""KeyOrdinal"",
ic.column_name as ""ColumnName"",
decode(i.uniqueness, 'UNIQUE', 1, 0) as ""IsUnique"",
decode(c.constraint_type, 'P', 1, 0) as ""IsPrimaryKey"",
decode(c.constraint_type, 'U', 1, 0) as ""IsUniqueConstraint"",
0 as ""IsClustered"",
sum(1) over (partition by i.table_owner, i.table_name, i.index_name order by i.table_owner) as ""ColumnCount"" 
from 
all_indexes i
inner join all_ind_columns ic on 1=1
    and ic.index_owner = i.owner
    and ic.index_name = i.index_name
    and ic.table_owner = i.table_owner
    and ic.table_owner = i.table_owner
left join (
    select 
    c.owner,
    c.constraint_type,
    c.constraint_name,
    c.table_name,
    cc.column_name,
    cc.position
    from 
    all_constraints c
    inner join all_cons_columns cc on cc.owner = c.owner and cc.constraint_name = c.constraint_name and cc.table_name = c.table_name
    where 1=1
    and constraint_type in('P', 'U')
) c on 1=1
    and c.owner = i.owner     
    and c.table_name = i.table_name
    and c.constraint_name = i.index_name 
";

        public SqlServerSchemaReader(DbConnection connection, DbProviderFactory factory)
            : base(connection, factory)
        {
        }

        private static string IncludeQueryTraceOn9481()
        {
            if (Settings.IncludeQueryTraceOn9481Flag)
                return @"
OPTION (QUERYTRACEON 9481)";
            return string.Empty;
        }

        private bool IsAzure(bool includeConnectionSettingComments)
        {
            return false;
        }

        public override Tables ReadSchema()
        {
            var result = new Tables();
            if(Cmd == null)
                return result;

            if(Settings.IncludeSynonyms)
                Cmd.CommandText = TableSQL;
            else
                Cmd.CommandText = TableSQL;

            Cmd.CommandTimeout = Settings.CommandTimeout;

            using(var rdr = Cmd.ExecuteReader())
            {
                var rxClean = new Regex("^(event|Equals|GetHashCode|GetType|ToString|repo|Save|IsNew|Insert|Update|Delete|Exists|SingleOrDefault|Single|First|FirstOrDefault|Fetch|Page|Query)$");
                var lastTable = string.Empty;
                Table table = null;
                while(rdr.Read())
                {
                    string schema = rdr["SchemaName"].ToString().Trim();
                    if(IsFilterExcluded(Settings.SchemaFilterExclude, Settings.SchemaFilterInclude, schema))
                        continue;

                    string tableName = rdr["TableName"].ToString().Trim();
                    if(IsFilterExcluded(Settings.TableFilterExclude, Settings.TableFilterInclude, tableName))
                        continue;

                    if(lastTable != tableName || table == null)
                    {
                        // The data from the database is not sorted
                        table = result.Find(x => x.Name == tableName && x.Schema == schema);
                        if(table == null)
                        {
                            table = new Table
                            {
                                Name = tableName,
                                Schema = schema,
                                IsView = string.Compare(rdr["TableType"].ToString().Trim(), "View", StringComparison.OrdinalIgnoreCase) == 0,

                                // Will be set later
                                HasForeignKey = false,
                                HasNullableColumns = false
                            };

                            if (!Settings.IncludeViews && table.IsView)
                                continue;

                            tableName = Settings.TableRename(tableName, schema, table.IsView);
                            if (IsFilterExcluded(Settings.TableFilterExclude, null, tableName)) // Retest exclusion filter after table rename
                                continue;

                            // Handle table names with underscores - singularise just the last word
                            table.ClassName = Inflector.MakeSingular(CleanUp(tableName));
                            var titleCase = (Settings.UsePascalCase ? Inflector.ToTitleCase(table.ClassName) : table.ClassName).Replace(" ", "").Replace("$", "").Replace(".", "");
                            table.NameHumanCase = titleCase;

                            if(Settings.PrependSchemaName && string.Compare(table.Schema, "dbo", StringComparison.OrdinalIgnoreCase) != 0)
                                table.NameHumanCase = table.Schema + "_" + table.NameHumanCase;

                            // Check for table or C# name clashes
                            if (ReservedKeywords.Contains(table.NameHumanCase) ||
                                (Settings.UsePascalCase && result.Find(x => x.NameHumanCase == table.NameHumanCase) != null))
                            {
                                table.NameHumanCase += "1";
                            }

                            if (!Settings.TableFilter(table))
                                continue;

                            result.Add(table);
                        }
                    }

                    var col = CreateColumn(rdr, rxClean, table, Settings.ColumnFilterExclude);
                    if(col != null)
                        table.Columns.Add(col);
                }
            }
            // Check for property name clashes in columns
            foreach(Column c in result.SelectMany(tbl => tbl.Columns.Where(c => tbl.Columns.FindAll(x => x.NameHumanCase == c.NameHumanCase).Count > 1)))
            {
                int n = 1;
                var original = c.NameHumanCase;
                c.NameHumanCase = original + n++;

                // Check if the above resolved the name clash, if not, use next value
                while(c.ParentTable.Columns.Count(c2 => c2.NameHumanCase == c.NameHumanCase) > 1)
                    c.NameHumanCase = original + n++;
            }

            if (Settings.IncludeExtendedPropertyComments != CommentsStyle.None)
                ReadExtendedProperties(result, Settings.IncludeConnectionSettingComments, Settings.IncludeExtendedPropertyComments == CommentsStyle.InSummaryBlock);

            ReadIndexes(result);

            foreach(Table tbl in result)
            {
                tbl.SetPrimaryKeys();
                foreach (Column c in tbl.Columns)
                    Settings.UpdateColumn(c, tbl);
                tbl.Columns.ForEach(x => x.SetupEntityAndConfig());
            }

            return result;
        }

        public override List<ForeignKey> ReadForeignKeys()
        {
            var fkList = new List<ForeignKey>();
            if(Cmd == null)
                return fkList;

            Cmd.CommandText = ForeignKeySQL;

            if (Settings.IncludeSynonyms)
                Cmd.CommandText = ForeignKeySQL;

            Cmd.CommandTimeout = Settings.CommandTimeout;

            using(DbDataReader rdr = Cmd.ExecuteReader())
            {
                while(rdr.Read())
                {
                    string fkTableName = rdr["FK_Table"].ToString();
                    string fkSchema = rdr["fkSchema"].ToString();
                    string pkTableName = rdr["PK_Table"].ToString();
                    string pkSchema = rdr["pkSchema"].ToString();
                    string fkColumn = rdr["FK_Column"].ToString();
                    string pkColumn = rdr["PK_Column"].ToString();
                    string constraintName = rdr["Constraint_Name"].ToString();
                    int ordinal = Convert.ToInt32(rdr["ORDINAL_POSITION"]);
                    bool cascadeOnDelete = (Convert.ToInt32(rdr["CascadeOnDelete"])) == 1;
                    bool isNotEnforced = Convert.ToBoolean(rdr["IsNotEnforced"]);

                    string fkTableNameFiltered = Settings.TableRename(fkTableName, fkSchema, false);
                    string pkTableNameFiltered = Settings.TableRename(pkTableName, pkSchema, false);

                    var fk = new ForeignKey(fkTableName, fkSchema, pkTableName, pkSchema, fkColumn, pkColumn,
                        constraintName, fkTableNameFiltered, pkTableNameFiltered, ordinal, cascadeOnDelete, isNotEnforced);

                    var filteredFk = Settings.ForeignKeyFilter(fk);
                    if(filteredFk != null)
                        fkList.Add(filteredFk);
                }
            }

            return fkList;
        }

        // When a table has no primary keys, all the NOT NULL columns are set as being the primary key.
        // This function reads the unique indexes for a table, and correctly sets the columns being used as primary keys.
        public override void ReadIndexes(Tables tables)
        {
            if (Cmd == null)
                return;

            if (Cmd.GetType().Name == "SqlCeCommand")
                return;

            Cmd.CommandText = IndexSQL + IncludeQueryTraceOn9481();
            Cmd.CommandTimeout = Settings.CommandTimeout;

            var list = new List<Index>();
            using (DbDataReader rdr = Cmd.ExecuteReader())
            {
                while (rdr.Read())
                {
                    var index = new Index
                    {
                        Schema             = rdr["TableSchema"].ToString().Trim(),
                        TableName          = rdr["TableName"].ToString().Trim(),
                        IndexName          = rdr["IndexName"].ToString().Trim(),
                        KeyOrdinal         = Convert.ToByte(rdr["KeyOrdinal"]),
                        ColumnName         = rdr["ColumnName"].ToString().Trim(),
                        ColumnCount        = Convert.ToInt32(rdr["ColumnCount"]),
                        IsUnique           = Convert.ToBoolean(rdr["IsUnique"]),
                        IsPrimaryKey       = Convert.ToBoolean(rdr["IsPrimaryKey"]),
                        IsUniqueConstraint = Convert.ToBoolean(rdr["IsUniqueConstraint"]),
                        IsClustered        = Convert.ToInt32(rdr["IsClustered"]) == 1
                    };

                    list.Add(index);
                }
            }

            Table t = null;
            var indexTables = list
                .Select(x => new { x.Schema, x.TableName })
                .Distinct();

            foreach (var indexTable in indexTables)
            {
                // Lookup table
                if (t == null || t.Name != indexTable.TableName || t.Schema != indexTable.Schema)
                    t = tables.Find(x => x.Name == indexTable.TableName && x.Schema == indexTable.Schema);

                if (t == null)
                    continue;

                // Find indexes for table
                var indexes =
                    list.Where(x => x.Schema == indexTable.Schema && x.TableName == indexTable.TableName)
                        .OrderBy(o => o.ColumnCount)
                        .ThenBy(o => o.KeyOrdinal)
                        .ToList();

                // Set index on column
                foreach (var index in indexes)
                {
                    var col = t.Columns.Find(x => x.Name == index.ColumnName);
                    if (col == null)
                        continue;

                    col.Indexes.Add(index);

                    col.IsPrimaryKey = col.IsPrimaryKey || index.IsPrimaryKey;
                    col.IsUniqueConstraint = col.IsUniqueConstraint || (index.IsUniqueConstraint && index.ColumnCount == 1);
                    col.IsUnique = col.IsUnique || (index.IsUnique && index.ColumnCount == 1);
                }

                // Check if table has any primary keys
                if (t.PrimaryKeys.Any())
                    continue; // Already has a primary key, ignore this unique index / constraint

                // Find unique indexes for table
                var uniqueIndexKeys = indexes
                    .Where(x => x.IsUnique || x.IsPrimaryKey || x.IsUniqueConstraint)
                    .OrderBy(o => o.ColumnCount)
                    .ThenBy(o => o.KeyOrdinal);

                // Process only the first index with the lowest unique column count
                string indexName = null;
                foreach (var key in uniqueIndexKeys)
                {
                    if (indexName == null)
                        indexName = key.IndexName;

                    if (indexName != key.IndexName)
                        break; // First unique index with lowest column count has been processed, exit.

                    var col = t.Columns.Find(x => x.Name == key.ColumnName);
                    if (col != null && !col.IsNullable && !col.Hidden && !col.IsPrimaryKey)
                    {
                        col.IsPrimaryKey = true;
                        col.IsUniqueConstraint = true;
                        col.IsUnique = true;
                        col.UniqueIndexName = indexName;
                    }
                }
            }
        }

        public override void ReadExtendedProperties(Tables tables, bool includeConnectionSettingComments, bool commentsInSummaryBlock)
        {
            if(Cmd == null)
                return;
        }

        public override List<StoredProcedure> ReadStoredProcs()
        {
            var result = new List<StoredProcedure>();
            if(Cmd == null)
                return result;

            if (Cmd.GetType().Name == "SqlCeCommand")
                return result;

            
            Cmd.CommandText = StoredProcedureSQL;

            Cmd.CommandTimeout = Settings.CommandTimeout;

            using(DbDataReader rdr = Cmd.ExecuteReader())
            {
                var lastSp = string.Empty;
                StoredProcedure sp = null;
                while (rdr.Read())
                {
                    var spType = rdr["ROUTINE_TYPE"].ToString().Trim().ToUpper();
                    var isTVF = (spType == "FUNCTION");
                    if (isTVF && !Settings.IncludeTableValuedFunctions)
                        continue;

                    string schema = rdr["SPECIFIC_SCHEMA"].ToString().Trim();
                    if(Settings.SchemaFilterExclude != null && Settings.SchemaFilterExclude.IsMatch(schema))
                        continue;

                    string spName = rdr["SPECIFIC_NAME"].ToString().Trim();
                    var fullname = schema + "." + spName;
                    if(Settings.StoredProcedureFilterExclude != null && (Settings.StoredProcedureFilterExclude.IsMatch(spName) || Settings.StoredProcedureFilterExclude.IsMatch(fullname)))
                        continue;

                    if (lastSp != fullname || sp == null)
                    {
                        lastSp = fullname;
                        sp = new StoredProcedure
                        {
                            IsTVF = isTVF,
                            Name = spName,
                            NameHumanCase = (Settings.UsePascalCase ? Inflector.ToTitleCase(spName) : spName).Replace(" ", "").Replace("$", ""),
                            Schema = schema
                        };
                        sp.NameHumanCase = CleanUp(sp.NameHumanCase);
                        if((string.Compare(schema, "dbo", StringComparison.OrdinalIgnoreCase) != 0) && Settings.PrependSchemaName)
                            sp.NameHumanCase = schema + "_" + sp.NameHumanCase;

                        sp.NameHumanCase = Settings.StoredProcedureRename(sp);
                        if(Settings.StoredProcedureFilterExclude != null && (Settings.StoredProcedureFilterExclude.IsMatch(sp.NameHumanCase) || Settings.StoredProcedureFilterExclude.IsMatch(schema + "." + sp.NameHumanCase)))
                            continue;

                        result.Add(sp);
                    }

                    if (rdr["DATA_TYPE"] != null && rdr["DATA_TYPE"] != DBNull.Value)
                    {
                        var typename = rdr["DATA_TYPE"].ToString().Trim().ToLower();
                        var scale = Convert.ToInt32(rdr["NUMERIC_SCALE"]);
                        var precision = Convert.ToInt32(rdr["NUMERIC_PRECISION"]);
                        var parameterMode = rdr["PARAMETER_MODE"].ToString().Trim().ToUpper();
						var maxLength = Convert.ToInt32(rdr["CHARACTER_MAXIMUM_LENGTH"]);
						var dateTimePrecision = Convert.ToInt32(rdr["DATETIME_PRECISION"]);
						
                        var param = new StoredProcedureParameter
                        {
                            Ordinal             = Convert.ToInt32(rdr["ORDINAL_POSITION"]),
                            Mode                = parameterMode == "IN" ? StoredProcedureParameterMode.In : StoredProcedureParameterMode.InOut,
                            Name                = rdr["PARAMETER_NAME"].ToString().Trim(),
                            SqlDbType           = GetSqlDbType(typename),
                            PropertyType        = GetPropertyType(typename, maxLength, precision, dateTimePrecision, scale),
                            DateTimePrecision   = dateTimePrecision,
                            MaxLength           = maxLength,
                            Precision           = precision,
                            Scale               = scale,
                            UserDefinedTypeName = rdr["USER_DEFINED_TYPE"].ToString().Trim()
                        };

                        var clean = CleanUp(param.Name.Replace("@", ""));
                        if (!string.IsNullOrEmpty(clean))
                        {
                            param.NameHumanCase = Inflector.MakeInitialLower((Settings.UsePascalCase ? Inflector.ToTitleCase(clean) : clean).Replace(" ", ""));

                            if (ReservedKeywords.Contains(param.NameHumanCase))
                                param.NameHumanCase = "@" + param.NameHumanCase;

                            sp.Parameters.Add(param);
                        }
                    }
                }
            }
            return result;
        }

        public void ReadStoredProcReturnObject(SqlConnection sqlConnection, StoredProcedure proc)
        {
            try
            {
                const string structured = "Structured";
                var sb = new StringBuilder();
                sb.AppendLine();
                sb.AppendLine("SET FMTONLY OFF; SET FMTONLY ON;");
                if (proc.IsTVF)
                {
                    foreach (var param in proc.Parameters.Where(x => x.SqlDbType.Equals(structured, StringComparison.InvariantCultureIgnoreCase)))
                        sb.AppendLine(string.Format("DECLARE {0} {1};", param.Name, param.UserDefinedTypeName));

                    sb.Append(string.Format("SELECT * FROM [{0}].[{1}](", proc.Schema, proc.Name));
                    foreach (var param in proc.Parameters)
                        sb.Append(string.Format("{0}, ", param.SqlDbType.Equals(structured, StringComparison.InvariantCultureIgnoreCase) ? param.Name : "null"));

                    if(proc.Parameters.Count > 0)
                        sb.Length -= 2;

                    sb.AppendLine(");");
                }
                else
                {
                    foreach (var param in proc.Parameters)
                        sb.AppendLine(string.Format("DECLARE {0} {1};", param.Name, param.SqlDbType.Equals(structured, StringComparison.InvariantCultureIgnoreCase) ? param.UserDefinedTypeName : param.SqlDbType));

                    sb.Append(string.Format("exec [{0}].[{1}] ", proc.Schema, proc.Name));
                    foreach (var param in proc.Parameters)
                        sb.Append(string.Format("{0}, ", param.Name));

                    if(proc.Parameters.Count > 0)
                        sb.Length -= 2;

                    sb.AppendLine(";");
                }
                sb.AppendLine("SET FMTONLY OFF; SET FMTONLY OFF;");

                var ds = new DataSet();
                using (var sqlAdapter = new SqlDataAdapter(sb.ToString(), sqlConnection))
                {
                    if (sqlConnection.State != ConnectionState.Open)
                        sqlConnection.Open();
                    sqlAdapter.SelectCommand.ExecuteReader(CommandBehavior.SchemaOnly | CommandBehavior.KeyInfo);
                    sqlConnection.Close();
                    sqlAdapter.FillSchema(ds, SchemaType.Source, "MyTable");
                }

                // Tidy up parameters
                foreach (var p in proc.Parameters)
                    p.NameHumanCase = Regex.Replace(p.NameHumanCase, @"[^A-Za-z0-9@\s]*", "");

                for(var count = 0; count < ds.Tables.Count; count++)
                {
                    proc.ReturnModels.Add(ds.Tables[count].Columns.Cast<DataColumn>().ToList());
                }
            }
            catch (Exception)
            {
                // Stored procedure does not have a return type
            }
        }

        public override void ProcessForeignKeys(List<ForeignKey> fkList, Tables tables, bool checkForFkNameClashes)
        {
            var constraints = fkList.Select(x => x.FkSchema + "." + x.ConstraintName).Distinct();
            foreach (var constraint in constraints)
            {
                var foreignKeys = fkList
                    .Where(x => string.Format("{0}.{1}", x.FkSchema, x.ConstraintName).Equals(constraint, StringComparison.InvariantCultureIgnoreCase))
                    .ToList();

                var foreignKey = foreignKeys.First();
                Table fkTable = tables.GetTable(foreignKey.FkTableName, foreignKey.FkSchema);
                if (fkTable == null || fkTable.IsMapping || !fkTable.HasForeignKey)
                    continue;

                Table pkTable = tables.GetTable(foreignKey.PkTableName, foreignKey.PkSchema);
                if (pkTable == null || pkTable.IsMapping)
                    continue;

                var fkCols = foreignKeys.Select(x => new
                    {
                        fk = x,
                        col = fkTable.Columns.Find(n => string.Equals(n.Name, x.FkColumn, StringComparison.InvariantCultureIgnoreCase))
                    })
                    .Where(x => x.col != null)
                    .OrderBy(o => o.fk.Ordinal)
                    .ToList();

                if (!fkCols.Any())
                    continue;

                //if(EF6)
                {
                    // Check FK has same number of columns as the primary key it points to
                    var pks = pkTable.PrimaryKeys.OrderBy(x => x.PropertyType).ThenBy(y => y.Name).ToArray();
                    var cols = fkCols.Select(x => x.col).OrderBy(x => x.PropertyType).ThenBy(y => y.Name).ToArray();
                    if (pks.Length != cols.Length)
                        continue;

                    // EF6 - Cannot have a FK to a non-primary key
                    if(pks.Where((pk, ef6Check) => pk.PropertyType != cols[ef6Check].PropertyType).Any())
                        continue;
                }

                var pkCols = foreignKeys.Select(x => pkTable.Columns.Find(n => string.Equals(n.Name, x.PkColumn, StringComparison.InvariantCultureIgnoreCase)))
                                        .Where(x => x != null)
                                        .OrderBy(o => o.Ordinal)
                                        .ToList();

                if (!pkCols.Any())
                    continue;

                var relationship = CalcRelationship(pkTable, fkTable, fkCols.Select(c => c.col).ToList(), pkCols);
                if (relationship == Relationship.DoNotUse)
                    continue;

                if(fkCols.All(x => !x.col.IsNullable && !x.col.Hidden) && pkCols.All(x => x.IsPrimaryKey || x.IsUnique))
                {
                    foreach (var fk in fkCols)
                        fk.fk.IncludeRequiredAttribute = true;
                }

                var fkCol = fkCols.First();
                var pkCol = pkCols.First();

                foreignKey = Settings.ForeignKeyProcessing(foreignKeys, fkTable, pkTable, fkCols.Any(x => x.col.IsNullable));

                string pkTableHumanCaseWithSuffix = foreignKey.PkTableHumanCase(pkTable.Suffix);
                string pkTableHumanCase = foreignKey.PkTableHumanCase( null);
                string pkPropName = fkTable.GetUniqueColumnName(pkTableHumanCase, foreignKey, checkForFkNameClashes, true, Relationship.ManyToOne);
                bool fkMakePropNameSingular = (relationship == Relationship.OneToOne);
                string fkPropName = pkTable.GetUniqueColumnName(fkTable.NameHumanCase, foreignKey, checkForFkNameClashes, fkMakePropNameSingular, Relationship.OneToMany);

                var dataAnnotation = string.Empty;
                if (Settings.UseDataAnnotations)
                {
                    dataAnnotation = string.Format("[ForeignKey(\"{0}\"){1}] ",
                        string.Join(", ", fkCols.Select(x => x.col.NameHumanCase).Distinct().ToArray()),
                        foreignKey.IncludeRequiredAttribute ? ", Required" : string.Empty
                    );

                    if (!checkForFkNameClashes &&
                        relationship == Relationship.OneToOne &&
                        foreignKey.IncludeReverseNavigation &&
                        fkCols.All(x => x.col.IsPrimaryKey))
                    {
                        var principalEndAttribute = string.Format("ForeignKey(\"{0}\")", pkPropName);
                        foreach (var fk in fkCols)
                        {
                            if (!fk.col.DataAnnotations.Contains(principalEndAttribute))
                                fk.col.DataAnnotations.Add(principalEndAttribute);
                        }
                    }
                }

                var fkd = new PropertyAndComments
                {
                    AdditionalDataAnnotations = Settings.ForeignKeyAnnotationsProcessing(fkTable, pkTable, pkPropName),
                    Definition = string.Format("{0}public {1}{2} {3} {4}{5}", dataAnnotation,
                        Table.GetLazyLoadingMarker(),
                        pkTableHumanCaseWithSuffix,
                        pkPropName,
                        "{ get; set; }",
                        Settings.IncludeComments != CommentsStyle.None ? " // " + foreignKey.ConstraintName : string.Empty),
                    Comments = string.Format("Parent {0} pointed by [{1}].({2}) ({3})",
                        pkTableHumanCase,
                        fkTable.Name,
                        string.Join(", ", fkCols.Select(x => "[" + x.col.NameHumanCase + "]").Distinct().ToArray()),
                        foreignKey.ConstraintName)
                };
                fkCol.col.EntityFk.Add(fkd);

                string manyToManyMapping, mapKey;
                if(foreignKeys.Count > 1)
                {
                    manyToManyMapping = string.Format("c => new {{ {0} }}", string.Join(", ", fkCols.Select(x => "c." + x.col.NameHumanCase).Distinct().ToArray()));
                    mapKey = string.Format("{0}", string.Join(",", fkCols.Select(x => "\"" + x.col.Name + "\"").Distinct().ToArray()));
                } else {
                    manyToManyMapping = string.Format("c => c.{0}", fkCol.col.NameHumanCase);
                    mapKey = string.Format("\"{0}\"", fkCol.col.Name);
                }

                if (!Settings.UseDataAnnotations)
                {
                    fkCol.col.ConfigFk.Add(string.Format("{0};{1}", GetRelationship(relationship, fkCol.col, pkCol, pkPropName, fkPropName, manyToManyMapping, mapKey, foreignKey.CascadeOnDelete, foreignKey.IncludeReverseNavigation, foreignKey.IsNotEnforced),
                        Settings.IncludeComments != CommentsStyle.None ? " // " + foreignKey.ConstraintName : string.Empty));
                }

                if(foreignKey.IncludeReverseNavigation)
                    pkTable.AddReverseNavigation(relationship, pkTableHumanCase, fkTable, fkPropName, string.Format("{0}.{1}", fkTable.Name, foreignKey.ConstraintName), foreignKeys);
            }
        }

        public override void IdentifyForeignKeys(List<ForeignKey> fkList, Tables tables)
        {
            foreach(var foreignKey in fkList)
            {
                Table fkTable = tables.GetTable(foreignKey.FkTableName, foreignKey.FkSchema);
                if(fkTable == null)
                    continue;   // Could be filtered out

                Table pkTable = tables.GetTable(foreignKey.PkTableName, foreignKey.PkSchema);
                if(pkTable == null)
                    continue;   // Could be filtered out

                Column fkCol = fkTable.Columns.Find(n => string.Equals(n.Name, foreignKey.FkColumn, StringComparison.InvariantCultureIgnoreCase));
                if(fkCol == null)
                    continue;   // Could not find fk column

                Column pkCol = pkTable.Columns.Find(n => string.Equals(n.Name, foreignKey.PkColumn, StringComparison.InvariantCultureIgnoreCase));
                if(pkCol == null)
                    continue;   // Could not find pk column

                fkTable.HasForeignKey = true;
            }
        }

        private static string GetRelationship(Relationship relationship, Column fkCol, Column pkCol, string pkPropName, string fkPropName, string manyToManyMapping, string mapKey, bool cascadeOnDelete, bool includeReverseNavigation, bool isNotEnforced)
        {
            return string.Format("Has{0}(a => a.{1}){2}{3}",
                GetHasMethod(relationship, fkCol, pkCol, isNotEnforced),
                pkPropName,
                GetWithMethod(relationship, fkCol, fkPropName, manyToManyMapping, mapKey, includeReverseNavigation),
                cascadeOnDelete ? string.Empty: ".WillCascadeOnDelete(false)");
        }

        // HasOptional
        // HasRequired
        // HasMany
        private static string GetHasMethod(Relationship relationship, Column fkCol, Column pkCol, bool isNotEnforced)
        {
            bool withMany = false;
            switch (relationship)
            {
                case Relationship.ManyToOne:
                case Relationship.ManyToMany:
                    withMany = true;
                    break;
            }

            if (withMany || pkCol.IsPrimaryKey || pkCol.IsUniqueConstraint || pkCol.IsUnique)
                return fkCol.IsNullable || isNotEnforced ? "Optional" : "Required";

            return "Many";
        }

        // WithOptional
        // WithRequired
        // WithMany
        // WithRequiredPrincipal
        // WithRequiredDependent
        private static string GetWithMethod(Relationship relationship, Column fkCol, string fkPropName, string manyToManyMapping, string mapKey, bool includeReverseNavigation)
        {
            string withParam = includeReverseNavigation ? string.Format("b => b.{0}", fkPropName) : string.Empty;
            switch (relationship)
            {
                case Relationship.OneToOne:
                    return string.Format(".WithOptional({0})", withParam);

                case Relationship.OneToMany:
                    return string.Format(".WithRequiredDependent({0})", withParam);

                case Relationship.ManyToOne:
                    if (!fkCol.Hidden)
                        return string.Format(".WithMany({0}).HasForeignKey({1})", withParam, manyToManyMapping);   // Foreign Key Association
                    return string.Format(".WithMany({0}).Map(c => c.MapKey({1}))", withParam, mapKey);  // Independent Association

                case Relationship.ManyToMany:
                    return string.Format(".WithMany({0}).HasForeignKey({1})", withParam, manyToManyMapping);

                default:
                    throw new ArgumentOutOfRangeException("relationship");
            }
        }

        private static Column CreateColumn(IDataRecord rdr, Regex rxClean, Table table, Regex columnFilterExclude)
        {
            if(rdr == null)
                throw new ArgumentNullException("rdr");

            string typename = rdr["TypeName"].ToString().Trim().ToLower();
            
			var maxLength = Convert.ToInt32(rdr["MaxLength"]);
            var precision = Convert.ToInt32( rdr["Precision"]);
			var dateTimePrecision = Convert.ToInt32(rdr["DateTimePrecision"]);
			var scale = Convert.ToInt32(rdr["Scale"]);

            var col = new Column
            {
                Name = rdr["ColumnName"].ToString().Trim(),
                SqlPropertyType = typename,
                PropertyType = GetPropertyType(typename, maxLength, precision, dateTimePrecision, scale),
                MaxLength = Convert.ToInt32(rdr["MaxLength"]),
                Precision = precision,
                Default = rdr["Default"].ToString().Trim(),
                DateTimePrecision = Convert.ToInt32(rdr["DateTimePrecision"]),
                Scale = scale,
                Ordinal = Convert.ToInt32(rdr["Ordinal"]),
                IsIdentity = Convert.ToBoolean(rdr["IsIdentity"]),
                IsNullable = Convert.ToBoolean(rdr["IsNullable"]),
                IsStoreGenerated = Convert.ToBoolean(rdr["IsStoreGenerated"]),
                IsPrimaryKey = Convert.ToBoolean(rdr["PrimaryKey"]),
                PrimaryKeyOrdinal = Convert.ToInt32(rdr["PrimaryKeyOrdinal"]),
                IsForeignKey = Convert.ToBoolean(rdr["IsForeignKey"]),
                ParentTable = table
            };

			// TODO: NL Validate / Port to Oracle
			/*
            if (col.MaxLength == -1 && (col.SqlPropertyType.EndsWith("varchar", StringComparison.InvariantCultureIgnoreCase) || col.SqlPropertyType.EndsWith("varbinary", StringComparison.InvariantCultureIgnoreCase)))
                col.SqlPropertyType += "(max)";

            if (col.IsPrimaryKey && !col.IsIdentity && col.IsStoreGenerated && typename == "uniqueidentifier")
            {
                col.IsStoreGenerated = false;
                col.IsIdentity = true;
            }
			*/
            var fullName = string.Format("{0}.{1}.{2}", table.Schema, table.Name, col.Name);
            if(columnFilterExclude != null && !col.IsPrimaryKey && (columnFilterExclude.IsMatch(col.Name) || columnFilterExclude.IsMatch(fullName)))
                col.Hidden = true;

            col.IsFixedLength = (typename == "char" || typename == "nchar");
            col.IsUnicode = !(typename == "char" || typename == "varchar2");

			// TODO: NL Validate / Port to Oracle
            /*col.IsMaxLength = (typename == "ntext");

			col.IsRowVersion = col.IsStoreGenerated && !col.IsNullable && typename == "timestamp";
            if (col.IsRowVersion)
                col.MaxLength = 8;

            if(typename == "hierarchyid")
                col.MaxLength = 0;
			*/

            col.CleanUpDefault();
            col.NameHumanCase = CleanUp(col.Name);
            col.NameHumanCase = rxClean.Replace(col.NameHumanCase, "_$1");

            if (ReservedKeywords.Contains(col.NameHumanCase))
                col.NameHumanCase = "@" + col.NameHumanCase;

            col.DisplayName = ToDisplayName(col.Name);

            var titleCase = (Settings.UsePascalCase ? Inflector.ToTitleCase(col.NameHumanCase) : col.NameHumanCase).Replace(" ", "");
            if (titleCase != string.Empty)
                col.NameHumanCase = titleCase;

            // Make sure property name doesn't clash with class name
            if(col.NameHumanCase == table.NameHumanCase)
                col.NameHumanCase = col.NameHumanCase + "_";

            if(char.IsDigit(col.NameHumanCase[0]))
                col.NameHumanCase = "_" + col.NameHumanCase;

            table.HasNullableColumns = IsNullable(col);

            // If PropertyType is empty, return null. Most likely ignoring a column due to legacy (such as OData not supporting spatial types)
            if (string.IsNullOrEmpty(col.PropertyType))
                return null;

            return col;
        }

        private static string GetSqlDbType(string sqlType)
        {
            var sysType = "VarChar";
            switch(sqlType)
            {
                case "hierarchyid":
                    sysType = "VarChar";
                    break;

                case "bigint":
                    sysType = "BigInt";
                    break;

                case "binary":
                    sysType = "Binary";
                    break;

                case "bit":
                    sysType = "Bit";
                    break;

                case "char":
                    sysType = "Char";
                    break;

                case "datetime":
                    sysType = "DateTime";
                    break;

                case "decimal":
                    sysType = "Decimal";
                    break;

                case "float":
                    sysType = "Float";
                    break;

                case "image":
                    sysType = "Image";
                    break;

                case "int":
                    sysType = "Int";
                    break;

                case "money":
                    sysType = "Money";
                    break;

                case "nchar":
                    sysType = "NChar";
                    break;

                case "ntext":
                    sysType = "NText";
                    break;

                case "nvarchar":
                    sysType = "NVarChar";
                    break;

                case "real":
                    sysType = "Real";
                    break;

                case "uniqueidentifier":
                    sysType = "UniqueIdentifier";
                    break;

                case "smalldatetime":
                    sysType = "SmallDateTime";
                    break;

                case "smallint":
                    sysType = "SmallInt";
                    break;

                case "smallmoney":
                    sysType = "SmallMoney";
                    break;

                case "text":
                    sysType = "Text";
                    break;

                case "timestamp":
                    sysType = "Timestamp";
                    break;

                case "tinyint":
                    sysType = "TinyInt";
                    break;

                case "varbinary":
                    sysType = "VarBinary";
                    break;

                case "varchar":
                    sysType = "VarChar";
                    break;

                case "variant":
                    sysType = "Variant";
                    break;

                case "xml":
                    sysType = "Xml";
                    break;

                case "udt":
                    sysType = "Udt";
                    break;

                case "table type":
                case "structured":
                    sysType = "Structured";
                    break;

                case "date":
                    sysType = "Date";
                    break;

                case "time":
                    sysType = "Time";
                    break;

                case "datetime2":
                    sysType = "DateTime2";
                    break;

                case "datetimeoffset":
                    sysType = "DateTimeOffset";
                    break;
            }
            return sysType;
        }

        private static string GetPropertyType(string sqlType, int maxLength, int precision, int dateTimePrecision, int scale)
        {
            var sysType = "string";
            switch(sqlType)
            {
                case "number":
					if(scale == 0)
					{
						if(precision > 19 || precision == 0)
							sysType = "decimal";
						else if(precision > 9)
							sysType = "long";
					    else if(precision > 4)
							sysType = "int";
						else if(precision > 0)
							sysType = "short";
					}
                    else
					{
						sysType = "decimal";
					}
                    break;
				case "binary_float":
					sysType = "float";
					break;
				case "binary_double":
					sysType = "double";
					break;
                case "float":
				// https://docs.oracle.com/database/121/ODPNT/entityEDMmapping.htm#CIHDBBBA
				// EDM types do not support TimeSpan. Use Decimal to represent the total number of seconds. An application can obtain a TimeSpan by using the TimeSpan.FromSeconds static method.
				case "interval day to second":
				case "interval year to month":
                    sysType = "decimal";
                    break;
                case "date":
				case "timestamp":
				case "timestamp with local time zone":
                    sysType = "System.DateTime";
                    break;                
				case "timestamp with time zone":
                    sysType = "System.DateTimeOffset";
                    break;
				case "blob":
                    sysType = "byte[]";
                    break;
            }
            return sysType;
        }
    }

    public class ForeignKey
    {
        public string FkTableName { get; private set; }
        public string FkTableNameFiltered { get; private set; }
        public string FkSchema { get; private set; }
        public string PkTableName { get; private set; }
        public string PkTableNameFiltered { get; private set; }
        public string PkSchema { get; private set; }
        public string FkColumn { get; private set; }
        public string PkColumn { get; private set; }
        public string ConstraintName { get; private set; }
        public int Ordinal { get; private set; }
        public bool CascadeOnDelete { get; private set; }
        public bool IsNotEnforced { get; private set; }

        // User settable via ForeignKeyFilter callback
        public bool IncludeReverseNavigation { get; set; }
        public bool IncludeRequiredAttribute { get; set; }

        public ForeignKey(string fkTableName, string fkSchema, string pkTableName, string pkSchema, string fkColumn, string pkColumn, string constraintName, string fkTableNameFiltered, string pkTableNameFiltered, int ordinal, bool cascadeOnDelete, bool isNotEnforced)
        {
            ConstraintName = constraintName;
            PkColumn = pkColumn;
            FkColumn = fkColumn;
            PkSchema = pkSchema;
            PkTableName = pkTableName;
            FkSchema = fkSchema;
            FkTableName = fkTableName;
            FkTableNameFiltered = fkTableNameFiltered;
            PkTableNameFiltered = pkTableNameFiltered;
            Ordinal = ordinal;
            CascadeOnDelete = cascadeOnDelete;
            IsNotEnforced = isNotEnforced;

            IncludeReverseNavigation = true;
        }

        public string PkTableHumanCase(string suffix)
        {
            var singular = Inflector.MakeSingular(PkTableNameFiltered);
            var pkTableHumanCase = (Settings.UsePascalCase ? Inflector.ToTitleCase(singular) : singular).Replace(" ", "").Replace("$", "");
            if (string.Compare(PkSchema, "dbo", StringComparison.OrdinalIgnoreCase) != 0 && Settings.PrependSchemaName)
                pkTableHumanCase = PkSchema + "_" + pkTableHumanCase;
            pkTableHumanCase += suffix;
            return pkTableHumanCase;
        }
    }

    public class Index
    {
        public string Schema;
        public string TableName;
        public string IndexName;
        public byte KeyOrdinal;
        public string ColumnName;
        public int ColumnCount;
        public bool IsUnique;
        public bool IsPrimaryKey;
        public bool IsUniqueConstraint;
        public bool IsClustered;
    }

    public class Table
    {
        public string Name;
        public string NameHumanCase;
        public string Schema;
        public string Type;
        public string ClassName;
        public string Suffix;
        public string ExtendedProperty;
        public bool IsMapping;
        public bool IsView;
        public bool HasForeignKey;
        public bool HasNullableColumns;
        public bool HasPrimaryKey;

        public List<Column> Columns;
        public List<PropertyAndComments> ReverseNavigationProperty;
        public List<string> MappingConfiguration;
        public List<string> ReverseNavigationCtor;
        public List<string> ReverseNavigationUniquePropName;
        public List<string> ReverseNavigationUniquePropNameClashes;
        public List<string> DataAnnotations;

        public Table()
        {
            Columns = new List<Column>();
            ResetNavigationProperties();
            ReverseNavigationUniquePropNameClashes = new List<string>();
            DataAnnotations = new List<string>();
        }

        internal static string GetLazyLoadingMarker()
        {
            return Settings.UseLazyLoading ? "virtual " : string.Empty;
        }

        public string NameHumanCaseWithSuffix()
        {
            return NameHumanCase + Suffix;
        }

        public void ResetNavigationProperties()
        {
            MappingConfiguration = new List<string>();
            ReverseNavigationProperty = new List<PropertyAndComments>();
            ReverseNavigationCtor = new List<string>();
            ReverseNavigationUniquePropName = new List<string>();
            foreach (var col in Columns)
                col.ResetNavigationProperties();
        }

        public void SetPrimaryKeys()
        {
            HasPrimaryKey = Columns.Any(x => x.IsPrimaryKey);
            if(HasPrimaryKey)
                return; // Table has at least one primary key

            // This table is not allowed in EntityFramework as it does not have a primary key.
            // Therefore generate a composite key from all non-null fields.
            foreach(var col in Columns.Where(x => !x.IsNullable && !x.Hidden))
            {
                col.IsPrimaryKey = true;
                HasPrimaryKey = true;
            }
        }

        public IEnumerable<Column> PrimaryKeys
        {
            get
            {
                return Columns
                    .Where(x => x.IsPrimaryKey)
                    .OrderBy(x => x.PrimaryKeyOrdinal)
                    .ThenBy(x => x.Ordinal)
                    .ToList();
            }
        }

        public string PrimaryKeyNameHumanCase()
        {
            var data = PrimaryKeys.Select(x => "x." + x.NameHumanCase).ToList();
            var n = data.Count;
            if(n == 0)
                return string.Empty;
            if(n == 1)
                return "x => " + data.First();
            // More than one primary key
            return string.Format("x => new {{ {0} }}", string.Join(", ", data));
        }

        public Column this[string columnName]
        {
            get { return GetColumn(columnName); }
        }

        public Column GetColumn(string columnName)
        {
            return Columns.SingleOrDefault(x => string.Compare(x.Name, columnName, StringComparison.OrdinalIgnoreCase) == 0);
        }

        public string GetUniqueColumnName(string tableNameHumanCase, ForeignKey foreignKey, bool checkForFkNameClashes, bool makeSingular, Relationship relationship)
        {
            var addReverseNavigationUniquePropName = (checkForFkNameClashes || Name == foreignKey.FkTableName || (Name == foreignKey.PkTableName && foreignKey.IncludeReverseNavigation));
            if (ReverseNavigationUniquePropName.Count == 0)
            {
                ReverseNavigationUniquePropName.Add(NameHumanCase);
                ReverseNavigationUniquePropName.AddRange(Columns.Select(c => c.NameHumanCase));
            }

            if(!makeSingular)
                tableNameHumanCase = Inflector.MakePlural(tableNameHumanCase);

            if (checkForFkNameClashes && ReverseNavigationUniquePropName.Contains(tableNameHumanCase) && !ReverseNavigationUniquePropNameClashes.Contains(tableNameHumanCase))
                ReverseNavigationUniquePropNameClashes.Add(tableNameHumanCase); // Name clash

            // Attempt 1
            string fkName = (Settings.UsePascalCase ? Inflector.ToTitleCase(foreignKey.FkColumn) : foreignKey.FkColumn).Replace(" ", "").Replace("$", "");
            string name = Settings.ForeignKeyName(tableNameHumanCase, foreignKey, fkName, relationship, 1);
            string col;
            if (!ReverseNavigationUniquePropNameClashes.Contains(name) && !ReverseNavigationUniquePropName.Contains(name))
            {
                if(addReverseNavigationUniquePropName)
                {
                    ReverseNavigationUniquePropName.Add(name);
                }

                return name;
            }

            if(Name == foreignKey.FkTableName)
            {
                // Attempt 2
                if (fkName.ToLowerInvariant().EndsWith("id"))
                {
                    col = Settings.ForeignKeyName(tableNameHumanCase, foreignKey, fkName, relationship, 2);
                    if (checkForFkNameClashes && ReverseNavigationUniquePropName.Contains(col) &&
                        !ReverseNavigationUniquePropNameClashes.Contains(col))
                        ReverseNavigationUniquePropNameClashes.Add(col); // Name clash

                    if (!ReverseNavigationUniquePropNameClashes.Contains(col) &&
                        !ReverseNavigationUniquePropName.Contains(col))
                    {
                        if(addReverseNavigationUniquePropName)
                        {
                            ReverseNavigationUniquePropName.Add(col);
                        }

                        return col;
                    }
                }

                // Attempt 3
                col = Settings.ForeignKeyName(tableNameHumanCase, foreignKey, fkName, relationship, 3);
                if (checkForFkNameClashes && ReverseNavigationUniquePropName.Contains(col) &&
                    !ReverseNavigationUniquePropNameClashes.Contains(col))
                    ReverseNavigationUniquePropNameClashes.Add(col); // Name clash

                if (!ReverseNavigationUniquePropNameClashes.Contains(col) &&
                    !ReverseNavigationUniquePropName.Contains(col))
                {
                    if(addReverseNavigationUniquePropName)
                    {
                        ReverseNavigationUniquePropName.Add(col);
                    }

                    return col;
                }
            }

            // Attempt 4
            col = Settings.ForeignKeyName(tableNameHumanCase, foreignKey, fkName, relationship, 4);
            if (checkForFkNameClashes && ReverseNavigationUniquePropName.Contains(col) && !ReverseNavigationUniquePropNameClashes.Contains(col))
                ReverseNavigationUniquePropNameClashes.Add(col); // Name clash

            if (!ReverseNavigationUniquePropNameClashes.Contains(col) && !ReverseNavigationUniquePropName.Contains(col))
            {
                if(addReverseNavigationUniquePropName)
                {
                    ReverseNavigationUniquePropName.Add(col);
                }

                return col;
            }

            // Attempt 5
            for (int n = 1; n < 99; ++n)
            {
                col = Settings.ForeignKeyName(tableNameHumanCase, foreignKey, fkName, relationship, 5) + n;

                if (ReverseNavigationUniquePropName.Contains(col))
                    continue;

                if(addReverseNavigationUniquePropName)
                {
                    ReverseNavigationUniquePropName.Add(col);
                }

                return col;
            }

            // Give up
            return Settings.ForeignKeyName(tableNameHumanCase, foreignKey, fkName, relationship, 6);
        }

        public void AddReverseNavigation(Relationship relationship, string fkName, Table fkTable, string propName, string constraint, List<ForeignKey> fks, Table mappingTable = null)
        {
            var fkNames = "";
            switch (relationship)
            {
                case Relationship.OneToOne:
                case Relationship.OneToMany:
                case Relationship.ManyToOne:
                    fkNames = (fks.Count>1 ? "(" : "") + string.Join(", ", fks.Select(x => "[" + x.FkColumn + "]").Distinct().ToArray()) + (fks.Count>1 ? ")" : "");
                    break;
                case Relationship.ManyToMany:
                    break;
            }
            switch (relationship)
            {
                case Relationship.OneToOne:
                    ReverseNavigationProperty.Add(
                        new PropertyAndComments()
                        {
                            AdditionalDataAnnotations = Settings.ForeignKeyAnnotationsProcessing(fkTable, this, propName),
                            Definition = string.Format("public {0}{1} {2} {{ get; set; }}{3}", GetLazyLoadingMarker(), fkTable.NameHumanCaseWithSuffix(), propName, Settings.IncludeComments != CommentsStyle.None ? " // " + constraint : string.Empty),
                            Comments = string.Format("Parent (One-to-One) {0} pointed by [{1}].{2} ({3})", NameHumanCaseWithSuffix(), fkTable.Name, fkNames, fks.First().ConstraintName)
                        }
                    );
                    break;

                case Relationship.OneToMany:
                    ReverseNavigationProperty.Add(
                        new PropertyAndComments()
                        {
                            AdditionalDataAnnotations = Settings.ForeignKeyAnnotationsProcessing(fkTable, this, propName),
                            Definition = string.Format("public {0}{1} {2} {{ get; set; }}{3}", GetLazyLoadingMarker(), fkTable.NameHumanCaseWithSuffix(), propName, Settings.IncludeComments != CommentsStyle.None ? " // " + constraint : string.Empty),
                            Comments = string.Format("Parent {0} pointed by [{1}].{2} ({3})", NameHumanCaseWithSuffix(), fkTable.Name, fkNames, fks.First().ConstraintName)
                        }
                    );
                    break;

                case Relationship.ManyToOne:
                    string initialization1 = string.Empty;
                    if(Settings.UsePropertyInitializers)
                        initialization1 = string.Format(" = new {0}<{1}>();", Settings.CollectionType, fkTable.NameHumanCaseWithSuffix());
                    ReverseNavigationProperty.Add(
                        new PropertyAndComments()
                        {
                            AdditionalDataAnnotations = Settings.ForeignKeyAnnotationsProcessing(fkTable, this, propName),
                            Definition = string.Format("public {0}{1}<{2}> {3} {{ get; set; }}{4}{5}", GetLazyLoadingMarker(), Settings.CollectionInterfaceType, fkTable.NameHumanCaseWithSuffix(), propName, initialization1, Settings.IncludeComments != CommentsStyle.None ? " // " + constraint : string.Empty),
                            Comments = string.Format("Child {0} where [{1}].{2} point to this entity ({3})", Inflector.MakePlural(fkTable.NameHumanCase), fkTable.Name, fkNames, fks.First().ConstraintName)
                        }
                    );
                    ReverseNavigationCtor.Add(string.Format("{0} = new {1}<{2}>();", propName, Settings.CollectionType, fkTable.NameHumanCaseWithSuffix()));
                    break;

                case Relationship.ManyToMany:
                    string initialization2 = string.Empty;
                    if(Settings.UsePropertyInitializers)
                        initialization2 = string.Format(" = new {0}<{1}>();", Settings.CollectionType, fkTable.NameHumanCaseWithSuffix());
                    ReverseNavigationProperty.Add(
                        new PropertyAndComments()
                        {
                            AdditionalDataAnnotations = Settings.ForeignKeyAnnotationsProcessing(fkTable, this, propName),
                            Definition = string.Format("public {0}{1}<{2}> {3} {{ get; set; }}{4}{5}", GetLazyLoadingMarker(), Settings.CollectionInterfaceType, fkTable.NameHumanCaseWithSuffix(), propName, initialization2, Settings.IncludeComments != CommentsStyle.None ? " // Many to many mapping" : string.Empty),
                            Comments = string.Format("Child {0} (Many-to-Many) mapped by table [{1}]", Inflector.MakePlural(fkTable.NameHumanCase), mappingTable == null ? string.Empty : mappingTable.Name)
                        }
                    );

                    ReverseNavigationCtor.Add(string.Format("{0} = new {1}<{2}>();", propName, Settings.CollectionType, fkTable.NameHumanCaseWithSuffix()));
                    break;

                default:
                    throw new ArgumentOutOfRangeException("relationship");
            }
        }

        public void AddMappingConfiguration(ForeignKey left, ForeignKey right, string leftPropName, string rightPropName)
        {
            MappingConfiguration.Add(string.Format(@"HasMany(t => t.{0}).WithMany(t => t.{1}).Map(m =>
            {{
                m.ToTable(""{2}""{5});
                m.MapLeftKey(""{3}"");
                m.MapRightKey(""{4}"");
            }});", leftPropName, rightPropName, left.FkTableName, left.FkColumn, right.FkColumn, Settings.IsSqlCe ? string.Empty : ", \"" + left.FkSchema + "\""));
        }

        public void IdentifyMappingTable(List<ForeignKey> fkList, Tables tables, bool checkForFkNameClashes)
        {
            IsMapping = false;

            var nonReadOnlyColumns = Columns.Where(c => !c.IsIdentity && !c.IsRowVersion && !c.IsStoreGenerated && !c.Hidden).ToList();

            // Ignoring read-only columns, it must have only 2 columns to be a mapping table
            if (nonReadOnlyColumns.Count != 2)
                return;

            // Must have 2 primary keys
            if (nonReadOnlyColumns.Count(x => x.IsPrimaryKey) != 2)
                return;

            // No columns should be nullable
            if (nonReadOnlyColumns.Any(x => x.IsNullable))
                return;

            // Find the foreign keys for this table
            var foreignKeys = fkList.Where(x =>
                                            string.Compare(x.FkTableName, Name, StringComparison.OrdinalIgnoreCase) == 0 &&
                                            string.Compare(x.FkSchema, Schema, StringComparison.OrdinalIgnoreCase) == 0)
                                    .ToList();

            // Each column must have a foreign key, therefore check column and foreign key counts match
            if (foreignKeys.Select(x => x.FkColumn).Distinct().Count() != 2)
                return;

            ForeignKey left  = foreignKeys[0];
            ForeignKey right = foreignKeys[1];
            if (!left.IncludeReverseNavigation || !right.IncludeReverseNavigation)
                return;

            Table leftTable = tables.GetTable(left.PkTableName, left.PkSchema);
            if (leftTable == null)
                return;

            Table rightTable = tables.GetTable(right.PkTableName, right.PkSchema);
            if (rightTable == null)
                return;

            var leftPropName  = leftTable.GetUniqueColumnName(rightTable.NameHumanCase, right, checkForFkNameClashes, false, Relationship.ManyToOne); // relationship from the mapping table to each side is Many-to-One
            var rightPropName = rightTable.GetUniqueColumnName(leftTable.NameHumanCase, left, checkForFkNameClashes, false, Relationship.ManyToOne); // relationship from the mapping table to each side is Many-to-One
            leftTable.AddMappingConfiguration(left, right, leftPropName, rightPropName);

            IsMapping = true;
            rightTable.AddReverseNavigation(Relationship.ManyToMany, rightTable.NameHumanCase, leftTable, rightPropName, null, null, this);
            leftTable.AddReverseNavigation(Relationship.ManyToMany, leftTable.NameHumanCase, rightTable, leftPropName, null, null, this);
        }

        public void SetupDataAnnotations()
        {
            var schema = String.Empty;
            if(!Settings.IsSqlCe)
                schema = String.Format(", Schema = \"{0}\"", Schema);
            DataAnnotations = new List<string>
            {
                HasPrimaryKey
                    ? string.Format("Table(\"{0}\"{1})", Name, schema)
                    : "NotMapped"
            };

        }
    }

    public class Tables : List<Table>
    {
        public Table GetTable(string tableName, string schema)
        {
            return this.SingleOrDefault(x =>
                string.Compare(x.Name, tableName, StringComparison.OrdinalIgnoreCase) == 0 &&
                string.Compare(x.Schema, schema, StringComparison.OrdinalIgnoreCase) == 0);
        }

        public void SetPrimaryKeys()
        {
            foreach (var tbl in this)
            {
                tbl.SetPrimaryKeys();
            }
        }

        public void IdentifyMappingTables(List<ForeignKey> fkList, bool checkForFkNameClashes)
        {
            foreach(var tbl in this.Where(x => x.HasForeignKey))
            {
                tbl.IdentifyMappingTable(fkList, this, checkForFkNameClashes);
            }
        }

        public void ResetNavigationProperties()
        {
            foreach (var tbl in this)
            {
                tbl.ResetNavigationProperties();
            }
        }
    }

    // ***********************************************************************
    // ** Stored procedure callbacks

    public static readonly Func<StoredProcedure, string> WriteStoredProcFunctionName = sp => sp.NameHumanCase;

    public static readonly Func<StoredProcedure, bool> StoredProcHasOutParams = (sp) =>
    {
        return sp.Parameters.Any(x => x.Mode != StoredProcedureParameterMode.In);
    };

    public static readonly Func<StoredProcedure, bool, string> WriteStoredProcFunctionParams = (sp, includeProcResult) =>
    {
        var sb = new StringBuilder();
        int n = 1;
        int count = sp.Parameters.Count;
        foreach (var p in sp.Parameters.OrderBy(x => x.Ordinal))
        {
            sb.AppendFormat("{0}{1}{2} {3}{4}",
                p.Mode == StoredProcedureParameterMode.In ? "" : "out ",
                p.PropertyType,
                NotNullable.Contains(p.PropertyType.ToLower()) ? string.Empty : "?",
                p.NameHumanCase,
                (n++ < count) ? ", " : string.Empty);
        }
        if (includeProcResult && sp.ReturnModels.Count > 0 && sp.ReturnModels.First().Count > 0)
            sb.AppendFormat((sp.Parameters.Count > 0 ?  ", " : "") + "out int procResult");
        return sb.ToString();
    };

    public static readonly Func<StoredProcedure, string> WriteStoredProcFunctionOverloadCall = (sp) =>
    {
        var sb = new StringBuilder();
        foreach (var p in sp.Parameters.OrderBy(x => x.Ordinal))
        {
            sb.AppendFormat("{0}{1}, ",
                p.Mode == StoredProcedureParameterMode.In ? "" : "out ",
                p.NameHumanCase);
        }
        sb.Append("out procResult");
        return sb.ToString();
    };

    public static readonly Func<StoredProcedure, string> WriteStoredProcFunctionSqlAtParams = sp =>
    {
        var sb = new StringBuilder();
        int n = 1;
        int count = sp.Parameters.Count;
        foreach (var p in sp.Parameters.OrderBy(x => x.Ordinal))
        {
            sb.AppendFormat("{0}{1}{2}",
                p.Name,
                p.Mode == StoredProcedureParameterMode.In ? string.Empty : " OUTPUT",
                (n++ < count) ? ", " : string.Empty);
        }
        return sb.ToString();
    };

    public static readonly Func<StoredProcedureParameter, string> WriteStoredProcSqlParameterName = p => p.NameHumanCase + "Param";

    public static readonly Func<StoredProcedure, bool, string> WriteStoredProcFunctionDeclareSqlParameter = (sp, includeProcResult) =>
    {
        var sb = new StringBuilder();
        foreach (var p in sp.Parameters.OrderBy(x => x.Ordinal))
        {
            var isNullable = !NotNullable.Contains(p.PropertyType.ToLower());
            var getValueOrDefault = isNullable ? ".GetValueOrDefault()" : string.Empty;
            var isGeography = p.PropertyType == "System.Data.Entity.Spatial.DbGeography";

            sb.AppendLine(
                $"            var {WriteStoredProcSqlParameterName(p)} = new System.Data.SqlClient.SqlParameter"
                + $" {{ ParameterName = \"{p.Name}\", "
                + (isGeography ? "UdtTypeName = \"geography\"" : $"SqlDbType = System.Data.SqlDbType.{p.SqlDbType}")
                + ", Direction = System.Data.ParameterDirection."
                + (p.Mode == StoredProcedureParameterMode.In ? "Input" : "Output")
                + (p.Mode == StoredProcedureParameterMode.In
                    ? ", Value = " + (isGeography
                        ? $"Microsoft.SqlServer.Types.SqlGeography.Parse({p.NameHumanCase}.AsText())"
                        : p.NameHumanCase + getValueOrDefault)
                    : string.Empty)
                + (p.MaxLength != 0 ? ", Size = " + p.MaxLength : string.Empty)
                + ((p.Precision > 0 || p.Scale > 0) ? ", Precision = " + p.Precision + ", Scale = " + p.Scale : string.Empty)
                + (p.PropertyType.ToLower().Contains("datatable") ? ", TypeName = \"" + p.UserDefinedTypeName + "\"" : string.Empty)
                + " };");

                if (p.Mode == StoredProcedureParameterMode.In)
                {
                    sb.AppendFormat(
                        isNullable
                            ? "            if (!{0}.HasValue){1}                {0}Param.Value = System.DBNull.Value;{1}{1}"
                            : "            if ({0}Param.Value == null){1}                {0}Param.Value = System.DBNull.Value;{1}{1}",
                        p.NameHumanCase, Environment.NewLine);
                }
        }
        if(includeProcResult && sp.ReturnModels.Count < 2)
            sb.AppendLine("            var procResultParam = new System.Data.SqlClient.SqlParameter { ParameterName = \"@procResult\", SqlDbType = System.Data.SqlDbType.Int, Direction = System.Data.ParameterDirection.Output };");
        return sb.ToString();
    };

    public static readonly Func<StoredProcedure, string> WriteTableValuedFunctionDeclareSqlParameter = sp =>
    {
        var sb = new StringBuilder();
        foreach (var p in sp.Parameters.OrderBy(x => x.Ordinal))
        {
            sb.AppendLine(string.Format("            var {0}Param = new System.Data.Entity.Core.Objects.ObjectParameter(\"{1}\", typeof({2})) {{ Value = (object){3} }};",
                p.NameHumanCase,
                p.Name.Substring(1),
                p.PropertyType,
                p.NameHumanCase + (p.Mode == StoredProcedureParameterMode.In && NotNullable.Contains(p.PropertyType.ToLowerInvariant()) ? string.Empty : " ?? System.DBNull.Value" )));
        }
        return sb.ToString();
    };

    public static readonly Func<StoredProcedure, bool, string> WriteStoredProcFunctionSqlParameterAnonymousArray = (sp, includeProcResultParam) =>
    {
        var sb = new StringBuilder();
        bool hasParam = false;
        foreach (var p in sp.Parameters.OrderBy(x => x.Ordinal))
        {
            sb.Append(string.Format("{0}Param, ", p.NameHumanCase));
            hasParam = true;
        }
        if (includeProcResultParam)
            sb.Append("procResultParam");
        else if(hasParam)
            sb.Remove(sb.Length - 2, 2);
        return sb.ToString();
    };

    public static readonly Func<StoredProcedure, string> WriteTableValuedFunctionSqlParameterAnonymousArray = sp =>
    {
        if (sp.Parameters.Count == 0)
            return "new System.Data.Entity.Core.Objects.ObjectParameter[] { }";
        var sb = new StringBuilder();
        foreach (var p in sp.Parameters.OrderBy(x => x.Ordinal))
        {
            sb.Append(string.Format("{0}Param, ", p.NameHumanCase));
        }
        return sb.ToString().Substring(0, sb.Length - 2);
    };

    public static readonly Func<StoredProcedure, bool, string> WriteStoredProcFunctionSetSqlParameters = (sp, isFake) =>
    {
        var sb = new StringBuilder();
        foreach (var p in sp.Parameters.Where(x => x.Mode != StoredProcedureParameterMode.In).OrderBy(x => x.Ordinal))
        {
            var Default = string.Format("default({0})", p.PropertyType);
            var notNullable = NotNullable.Contains(p.PropertyType.ToLower());

            if(isFake)
                sb.AppendLine(string.Format("            {0} = {1};", p.NameHumanCase, Default));
            else
            {
                sb.AppendLine(string.Format("            if (IsSqlParameterNull({0}Param))", p.NameHumanCase));
                sb.AppendLine(string.Format("                {0} = {1};", p.NameHumanCase, notNullable ? Default : "null"));
                sb.AppendLine("            else");
                sb.AppendLine(string.Format("                {0} = ({1}) {2}Param.Value;", p.NameHumanCase, p.PropertyType, p.NameHumanCase));
            }
        }
        return sb.ToString();
    };

    public static readonly Func<StoredProcedure, string> WriteStoredProcReturnModelName = sp =>
    {
        if (Settings.StoredProcedureReturnTypes.ContainsKey(sp.NameHumanCase))
            return Settings.StoredProcedureReturnTypes[sp.NameHumanCase];
        if (Settings.StoredProcedureReturnTypes.ContainsKey(sp.Name))
            return Settings.StoredProcedureReturnTypes[sp.Name];

        var name = string.Format("{0}ReturnModel", sp.NameHumanCase);
        if (Settings.StoredProcedureReturnModelRename != null)
        {
            var customName = Settings.StoredProcedureReturnModelRename(name, sp);
            if (!string.IsNullOrEmpty(customName))
                name = customName;
        }

        return name;
    };

    public static readonly Func<DataColumn, string> WriteStoredProcReturnColumn = col =>
    {
        var columnName = ReservedKeywords.Contains(col.ColumnName) ? "@" + col.ColumnName : col.ColumnName;

        return string.Format("public {0} {1} {{ get; set; }}",
            StoredProcedure.WrapTypeIfNullable(
                (col.DataType.Name.Equals("SqlHierarchyId") ? "Microsoft.SqlServer.Types." : col.DataType.Namespace + ".") +
                col.DataType.Name, col),
            columnName);
    };

    public static readonly Func<StoredProcedure, string> WriteStoredProcReturnType = (sp) =>
    {
        var returnModelCount = sp.ReturnModels.Count;
        if (returnModelCount == 0)
            return "int";

        var spReturnClassName = WriteStoredProcReturnModelName(sp);
        return (returnModelCount == 1) ? string.Format("System.Collections.Generic.List<{0}>", spReturnClassName) : spReturnClassName;
    };

    /// <summary>
    /// Helper class in making dynamic class definitions easier.
    /// </summary>
    public sealed class BaseClassMaker
    {
        private string _typeName;
        private StringBuilder _interfaces;

        public BaseClassMaker(string baseClassName = null)
        {
            SetBaseClassName(baseClassName);
        }

        /// <summary>
        /// Sets the base-class name.
        /// </summary>
        public void SetBaseClassName(string typeName)
        {
            _typeName = typeName;
        }

        /// <summary>
        /// Appends additional implemented interface.
        /// </summary>
        public bool AddInterface(string typeName)
        {
            if (string.IsNullOrEmpty(typeName))
                return false;

            if (_interfaces == null)
            {
                _interfaces = new StringBuilder();
            }
            else
            {
                if (_interfaces.Length > 0)
                {
                    _interfaces.Append(", ");
                }
            }

            _interfaces.Append(typeName);
            return true;
        }

        /// <summary>
        /// Conditionally appends additional implemented interface.
        /// </summary>
        public bool AddInterface(string interfaceName, bool condition)
        {
            if (condition)
            {
                return AddInterface(interfaceName);
            }

            return false;
        }

        public override string ToString()
        {
            var hasInterfaces = _interfaces != null && _interfaces.Length > 0;

            if (string.IsNullOrEmpty(_typeName))
            {
                return hasInterfaces ? " : " + _interfaces : string.Empty;
            }

            return hasInterfaces ? string.Concat(" : ", _typeName, ", ", _interfaces) : " : " + _typeName;
        }
    }

#>
